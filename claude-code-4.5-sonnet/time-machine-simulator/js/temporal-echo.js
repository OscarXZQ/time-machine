class TemporalEchoChamber {
    constructor() {
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.echoEvents = [];
        this.temporalResonances = [];
        this.timeVortices = [];
        this.echoChambers = [];
        this.temporalFeedback = [];
        this.time = 0;
        this.echoIntensity = 1.0;\n        this.resonanceFrequency = 1.0;\n        this.chamberCount = 0;\n        \n        this.init();\n        this.createEchoSystems();\n        this.animate();\n    }\n    \n    init() {\n        this.canvas.style.position = 'fixed';\n        this.canvas.style.top = '0';\n        this.canvas.style.left = '0';\n        this.canvas.style.width = '100%';\n        this.canvas.style.height = '100%';\n        this.canvas.style.pointerEvents = 'none';\n        this.canvas.style.zIndex = '500'; // Highest layer\n        this.canvas.style.mixBlendMode = 'screen';\n        this.canvas.style.opacity = '0.8';\n        \n        this.resize();\n        document.body.appendChild(this.canvas);\n        \n        this.bindEvents();\n    }\n    \n    resize() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n        this.createEchoSystems();\n    }\n    \n    bindEvents() {\n        document.addEventListener('travel-start', () => {\n            this.createMajorEchoEvent();\n            this.amplifyResonance();\n        });\n        \n        document.addEventListener('calibrate-start', () => {\n            this.stabilizeEchoes();\n            this.createCalibrationResonance();\n        });\n        \n        document.addEventListener('mousemove', (e) => {\n            this.createLocalEcho(e.clientX, e.clientY);\n        });\n        \n        // Listen to other system events to create echoes\n        document.addEventListener('quantum-observation', (e) => {\n            this.createQuantumEcho(e.detail.x, e.detail.y);\n        });\n    }\n    \n    createEchoSystems() {\n        // Create initial echo chambers\n        const positions = [\n            { x: this.canvas.width * 0.2, y: this.canvas.height * 0.3 },\n            { x: this.canvas.width * 0.8, y: this.canvas.height * 0.3 },\n            { x: this.canvas.width * 0.2, y: this.canvas.height * 0.7 },\n            { x: this.canvas.width * 0.8, y: this.canvas.height * 0.7 },\n            { x: this.canvas.width * 0.5, y: this.canvas.height * 0.5 }\n        ];\n        \n        positions.forEach((pos, index) => {\n            this.echoChambers.push(new EchoChamber(\n                pos.x, pos.y, index\n            ));\n        });\n        \n        // Create initial temporal resonances\n        for (let i = 0; i < 6; i++) {\n            this.temporalResonances.push(new TemporalResonance(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height\n            ));\n        }\n    }\n    \n    createMajorEchoEvent() {\n        // Create massive temporal echo during time travel\n        const centerX = this.canvas.width / 2;\n        const centerY = this.canvas.height / 2;\n        \n        this.echoEvents.push(new TemporalEcho(\n            centerX, centerY, 'major'\n        ));\n        \n        // Create time vortex\n        this.timeVortices.push(new TimeVortex(centerX, centerY));\n        \n        // Activate all echo chambers\n        this.echoChambers.forEach(chamber => chamber.activate());\n        \n        // Create feedback loop\n        this.temporalFeedback.push(new TemporalFeedback(\n            centerX, centerY\n        ));\n    }\n    \n    amplifyResonance() {\n        this.echoIntensity = 3.0;\n        this.resonanceFrequency = 2.5;\n        \n        // Create additional resonances\n        for (let i = 0; i < 8; i++) {\n            const angle = (i / 8) * Math.PI * 2;\n            const distance = 150;\n            const centerX = this.canvas.width / 2;\n            const centerY = this.canvas.height / 2;\n            \n            this.temporalResonances.push(new TemporalResonance(\n                centerX + Math.cos(angle) * distance,\n                centerY + Math.sin(angle) * distance,\n                'amplified'\n            ));\n        }\n    }\n    \n    stabilizeEchoes() {\n        this.echoIntensity = 1.0;\n        this.resonanceFrequency = 1.0;\n        \n        // Stabilize all chambers\n        this.echoChambers.forEach(chamber => chamber.stabilize());\n    }\n    \n    createCalibrationResonance() {\n        // Create harmonic resonance pattern during calibration\n        const centerX = this.canvas.width / 2;\n        const centerY = this.canvas.height / 2;\n        \n        for (let i = 0; i < 5; i++) {\n            const radius = 80 + i * 40;\n            const points = 6;\n            \n            for (let j = 0; j < points; j++) {\n                const angle = (j / points) * Math.PI * 2;\n                this.temporalResonances.push(new TemporalResonance(\n                    centerX + Math.cos(angle) * radius,\n                    centerY + Math.sin(angle) * radius,\n                    'harmonic'\n                ));\n            }\n        }\n    }\n    \n    createLocalEcho(x, y) {\n        if (Math.random() < 0.15) {\n            this.echoEvents.push(new TemporalEcho(x, y, 'minor'));\n            \n            // Create resonance in nearby chambers\n            this.echoChambers.forEach(chamber => {\n                const distance = Math.sqrt(\n                    Math.pow(chamber.x - x, 2) + Math.pow(chamber.y - y, 2)\n                );\n                \n                if (distance < 150) {\n                    chamber.receiveEcho(x, y);\n                }\n            });\n        }\n    }\n    \n    createQuantumEcho(x, y) {\n        // Special echo for quantum events\n        this.echoEvents.push(new TemporalEcho(x, y, 'quantum'));\n        \n        // Create quantum resonance\n        this.temporalResonances.push(new TemporalResonance(x, y, 'quantum'));\n    }\n    \n    update() {\n        this.time += 0.016;\n        \n        // Update all systems\n        this.echoEvents = this.echoEvents.filter(echo => {\n            echo.update(this.time, this.echoIntensity);\n            \n            // Create secondary echoes when primary echoes reach other chambers\n            if (echo.shouldCreateSecondaryEcho()) {\n                this.createSecondaryEchoes(echo);\n            }\n            \n            return !echo.finished;\n        });\n        \n        this.temporalResonances = this.temporalResonances.filter(resonance => {\n            resonance.update(this.time, this.resonanceFrequency);\n            return !resonance.finished;\n        });\n        \n        this.timeVortices = this.timeVortices.filter(vortex => {\n            vortex.update(this.time);\n            return !vortex.finished;\n        });\n        \n        this.echoChambers.forEach(chamber => {\n            chamber.update(this.time, this.echoIntensity);\n        });\n        \n        this.temporalFeedback = this.temporalFeedback.filter(feedback => {\n            feedback.update(this.time);\n            return !feedback.finished;\n        });\n        \n        // Process inter-chamber echo propagation\n        this.processEchoPropagation();\n        \n        // Intensity and frequency decay\n        this.echoIntensity = Math.max(1.0, this.echoIntensity * 0.999);\n        this.resonanceFrequency = Math.max(1.0, this.resonanceFrequency * 0.998);\n        \n        // Spontaneous echo events\n        if (Math.random() < 0.003) {\n            this.createSpontaneousEcho();\n        }\n    }\n    \n    createSecondaryEchoes(primaryEcho) {\n        // Find chambers within echo range and create secondary echoes\n        this.echoChambers.forEach(chamber => {\n            const distance = Math.sqrt(\n                Math.pow(chamber.x - primaryEcho.x, 2) + \n                Math.pow(chamber.y - primaryEcho.y, 2)\n            );\n            \n            if (distance < primaryEcho.radius && distance > 50) {\n                // Create delayed secondary echo from chamber\n                setTimeout(() => {\n                    if (!primaryEcho.finished) {\n                        this.echoEvents.push(new TemporalEcho(\n                            chamber.x, chamber.y, 'secondary'\n                        ));\n                    }\n                }, distance * 2); // Delay based on distance\n            }\n        });\n    }\n    \n    processEchoPropagation() {\n        // Create connections between active chambers\n        const activeChambers = this.echoChambers.filter(chamber => chamber.isActive());\n        \n        for (let i = 0; i < activeChambers.length; i++) {\n            for (let j = i + 1; j < activeChambers.length; j++) {\n                const chamber1 = activeChambers[i];\n                const chamber2 = activeChambers[j];\n                \n                if (chamber1.shouldPropagateEcho(chamber2)) {\n                    // Create propagation line\n                    this.temporalFeedback.push(new TemporalFeedback(\n                        chamber1.x, chamber1.y, chamber2.x, chamber2.y\n                    ));\n                }\n            }\n        }\n    }\n    \n    createSpontaneousEcho() {\n        const eventType = Math.random();\n        \n        if (eventType < 0.4) {\n            // Random echo\n            this.echoEvents.push(new TemporalEcho(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height,\n                'spontaneous'\n            ));\n        } else if (eventType < 0.7) {\n            // Random resonance\n            this.temporalResonances.push(new TemporalResonance(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height,\n                'spontaneous'\n            ));\n        } else {\n            // Random chamber activation\n            if (this.echoChambers.length > 0) {\n                const chamber = this.echoChambers[Math.floor(Math.random() * this.echoChambers.length)];\n                chamber.spontaneousActivation();\n            }\n        }\n    }\n    \n    render() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        // Render temporal feedback lines (background)\n        this.temporalFeedback.forEach(feedback => feedback.render(this.ctx));\n        \n        // Render echo chambers\n        this.echoChambers.forEach(chamber => chamber.render(this.ctx));\n        \n        // Render temporal resonances\n        this.temporalResonances.forEach(resonance => resonance.render(this.ctx));\n        \n        // Render time vortices\n        this.timeVortices.forEach(vortex => vortex.render(this.ctx));\n        \n        // Render echo events\n        this.echoEvents.forEach(echo => echo.render(this.ctx));\n        \n        // Render echo statistics\n        this.renderEchoStats();\n    }\n    \n    renderEchoStats() {\n        this.ctx.save();\n        this.ctx.font = '11px monospace';\n        this.ctx.fillStyle = 'rgba(150, 255, 150, 0.8)';\n        \n        const activeEchoes = this.echoEvents.length;\n        const activeResonances = this.temporalResonances.length;\n        const activeChambers = this.echoChambers.filter(c => c.isActive()).length;\n        const feedbackLoops = this.temporalFeedback.length;\n        \n        this.ctx.fillText(`Echo Intensity: ${this.echoIntensity.toFixed(1)}x`, this.canvas.width - 280, this.canvas.height - 90);\n        this.ctx.fillText(`Resonance Freq: ${this.resonanceFrequency.toFixed(1)}x`, this.canvas.width - 280, this.canvas.height - 70);\n        this.ctx.fillText(`Active Echoes: ${activeEchoes}`, this.canvas.width - 280, this.canvas.height - 50);\n        this.ctx.fillText(`Resonances: ${activeResonances}`, this.canvas.width - 280, this.canvas.height - 30);\n        this.ctx.fillText(`Echo Chambers: ${activeChambers}/${this.echoChambers.length}`, this.canvas.width - 280, this.canvas.height - 10);\n        \n        this.ctx.restore();\n    }\n    \n    animate() {\n        this.update();\n        this.render();\n        requestAnimationFrame(() => this.animate());\n    }\n}\n\nclass TemporalEcho {\n    constructor(x, y, type = 'normal') {\n        this.x = x;\n        this.y = y;\n        this.type = type;\n        this.radius = 0;\n        this.maxRadius = this.getMaxRadius(type);\n        this.finished = false;\n        this.life = this.getLifespan(type);\n        this.maxLife = this.life;\n        this.echoRings = [];\n        this.intensity = this.getIntensity(type);\n        this.frequency = 1.0;\n        this.secondaryEchoCreated = false;\n        \n        this.createEchoRings();\n    }\n    \n    getMaxRadius(type) {\n        switch (type) {\n            case 'major': return 200;\n            case 'minor': return 80;\n            case 'secondary': return 60;\n            case 'quantum': return 100;\n            case 'spontaneous': return 50;\n            default: return 100;\n        }\n    }\n    \n    getLifespan(type) {\n        switch (type) {\n            case 'major': return 300;\n            case 'minor': return 120;\n            case 'secondary': return 100;\n            case 'quantum': return 150;\n            case 'spontaneous': return 80;\n            default: return 150;\n        }\n    }\n    \n    getIntensity(type) {\n        switch (type) {\n            case 'major': return 2.0;\n            case 'minor': return 0.8;\n            case 'secondary': return 0.6;\n            case 'quantum': return 1.5;\n            case 'spontaneous': return 0.5;\n            default: return 1.0;\n        }\n    }\n    \n    createEchoRings() {\n        const ringCount = this.type === 'major' ? 6 : 4;\n        \n        for (let i = 0; i < ringCount; i++) {\n            this.echoRings.push({\n                radius: 0,\n                speed: 1 + i * 0.3,\n                maxRadius: this.maxRadius + i * 15,\n                intensity: 1 - i * 0.15,\n                delay: i * 5\n            });\n        }\n    }\n    \n    shouldCreateSecondaryEcho() {\n        return !this.secondaryEchoCreated && \n               this.radius > this.maxRadius * 0.5 && \n               this.type === 'major';\n    }\n    \n    update(time, globalIntensity) {\n        // Update echo rings\n        this.echoRings.forEach(ring => {\n            if (ring.delay > 0) {\n                ring.delay--;\n            } else {\n                ring.radius += ring.speed;\n            }\n        });\n        \n        // Update main radius\n        this.radius = Math.min(this.maxRadius, this.radius + 2);\n        \n        // Frequency modulation\n        this.frequency = 1 + Math.sin(time * 3) * 0.3 * globalIntensity;\n        \n        // Mark secondary echo creation\n        if (this.shouldCreateSecondaryEcho()) {\n            this.secondaryEchoCreated = true;\n        }\n        \n        this.life--;\n        if (this.life <= 0) {\n            this.finished = true;\n        }\n    }\n    \n    render(ctx) {\n        const alpha = (this.life / this.maxLife) * this.intensity;\n        \n        ctx.save();\n        ctx.translate(this.x, this.y);\n        \n        // Render echo rings\n        this.echoRings.forEach(ring => {\n            if (ring.radius > 0 && ring.radius <= ring.maxRadius) {\n                const ringAlpha = (1 - ring.radius / ring.maxRadius) * ring.intensity * alpha;\n                const strokeWidth = this.type === 'major' ? 3 : 2;\n                \n                ctx.strokeStyle = this.getEchoColor(ringAlpha);\n                ctx.lineWidth = strokeWidth;\n                ctx.shadowBlur = 10;\n                ctx.shadowColor = this.getEchoColor(1.0).replace(/[\\d\\.]+\\)/, '1)');\n                \n                ctx.beginPath();\n                ctx.arc(0, 0, ring.radius * this.frequency, 0, Math.PI * 2);\n                ctx.stroke();\n                \n                // Echo distortion lines\n                if (this.type === 'major' || this.type === 'quantum') {\n                    for (let i = 0; i < 8; i++) {\n                        const angle = (i / 8) * Math.PI * 2;\n                        const innerRadius = ring.radius * 0.8;\n                        const outerRadius = ring.radius * 1.2;\n                        \n                        ctx.beginPath();\n                        ctx.moveTo(\n                            Math.cos(angle) * innerRadius,\n                            Math.sin(angle) * innerRadius\n                        );\n                        ctx.lineTo(\n                            Math.cos(angle) * outerRadius,\n                            Math.sin(angle) * outerRadius\n                        );\n                        ctx.stroke();\n                    }\n                }\n            }\n        });\n        \n        // Central echo source\n        const sourceGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);\n        sourceGradient.addColorStop(0, this.getEchoColor(alpha));\n        sourceGradient.addColorStop(0.7, this.getEchoColor(alpha * 0.5));\n        sourceGradient.addColorStop(1, 'transparent');\n        \n        ctx.fillStyle = sourceGradient;\n        ctx.beginPath();\n        ctx.arc(0, 0, 15, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Echo type label\n        if (this.type !== 'normal') {\n            ctx.font = '8px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;\n            ctx.textAlign = 'center';\n            ctx.fillText(this.type.toUpperCase(), 0, -this.maxRadius * 0.5 - 10);\n        }\n        \n        ctx.restore();\n    }\n    \n    getEchoColor(alpha) {\n        switch (this.type) {\n            case 'major': return `rgba(255, 100, 255, ${alpha})`;\n            case 'minor': return `rgba(100, 255, 100, ${alpha})`;\n            case 'secondary': return `rgba(100, 200, 255, ${alpha})`;\n            case 'quantum': return `rgba(255, 255, 100, ${alpha})`;\n            case 'spontaneous': return `rgba(200, 200, 200, ${alpha})`;\n            default: return `rgba(150, 255, 150, ${alpha})`;\n        }\n    }\n}\n\nclass TemporalResonance {\n    constructor(x, y, type = 'normal') {\n        this.x = x;\n        this.y = y;\n        this.type = type;\n        this.amplitude = 0;\n        this.maxAmplitude = this.getMaxAmplitude(type);\n        this.frequency = this.getFrequency(type);\n        this.phase = Math.random() * Math.PI * 2;\n        this.finished = false;\n        this.life = this.getLifespan(type);\n        this.maxLife = this.life;\n        this.harmonics = [];\n        this.resonanceNodes = [];\n        \n        this.createHarmonics();\n        this.createResonanceNodes();\n    }\n    \n    getMaxAmplitude(type) {\n        switch (type) {\n            case 'amplified': return 40;\n            case 'harmonic': return 30;\n            case 'quantum': return 35;\n            case 'spontaneous': return 20;\n            default: return 25;\n        }\n    }\n    \n    getFrequency(type) {\n        switch (type) {\n            case 'amplified': return 0.15;\n            case 'harmonic': return 0.08;\n            case 'quantum': return 0.12;\n            case 'spontaneous': return 0.1;\n            default: return 0.1;\n        }\n    }\n    \n    getLifespan(type) {\n        switch (type) {\n            case 'amplified': return 400;\n            case 'harmonic': return 600;\n            case 'quantum': return 300;\n            case 'spontaneous': return 200;\n            default: return 300;\n        }\n    }\n    \n    createHarmonics() {\n        const harmonicCount = this.type === 'harmonic' ? 5 : 3;\n        \n        for (let i = 1; i <= harmonicCount; i++) {\n            this.harmonics.push({\n                frequency: this.frequency * i,\n                amplitude: this.maxAmplitude / i,\n                phase: Math.random() * Math.PI * 2\n            });\n        }\n    }\n    \n    createResonanceNodes() {\n        for (let i = 0; i < 8; i++) {\n            const angle = (i / 8) * Math.PI * 2;\n            const distance = 20 + Math.random() * 15;\n            \n            this.resonanceNodes.push({\n                angle: angle,\n                distance: distance,\n                phase: Math.random() * Math.PI * 2,\n                intensity: Math.random()\n            });\n        }\n    }\n    \n    update(time, globalFrequency) {\n        this.phase += this.frequency * globalFrequency;\n        \n        // Update amplitude\n        if (this.life > this.maxLife * 0.8) {\n            this.amplitude = Math.min(this.maxAmplitude, this.amplitude + 1);\n        } else {\n            this.amplitude *= 0.995;\n        }\n        \n        // Update harmonics\n        this.harmonics.forEach(harmonic => {\n            harmonic.phase += harmonic.frequency * globalFrequency;\n        });\n        \n        // Update resonance nodes\n        this.resonanceNodes.forEach(node => {\n            node.phase += 0.05;\n            node.intensity = 0.5 + Math.sin(node.phase) * 0.5;\n        });\n        \n        this.life--;\n        if (this.life <= 0) {\n            this.finished = true;\n        }\n    }\n    \n    render(ctx) {\n        const alpha = this.life / this.maxLife;\n        const currentAmplitude = this.amplitude + Math.sin(this.phase) * 5;\n        \n        ctx.save();\n        ctx.translate(this.x, this.y);\n        \n        // Render harmonics\n        this.harmonics.forEach((harmonic, index) => {\n            const harmonicRadius = Math.abs(harmonic.amplitude + Math.sin(harmonic.phase) * 10);\n            const harmonicAlpha = alpha * (1 - index * 0.2);\n            \n            ctx.strokeStyle = this.getResonanceColor(harmonicAlpha, index);\n            ctx.lineWidth = 1;\n            ctx.shadowBlur = 5;\n            ctx.shadowColor = this.getResonanceColor(1.0, index).replace(/[\\d\\.]+\\)/, '1)');\n            \n            ctx.beginPath();\n            ctx.arc(0, 0, harmonicRadius, 0, Math.PI * 2);\n            ctx.stroke();\n        });\n        \n        // Render resonance nodes\n        this.resonanceNodes.forEach(node => {\n            const nodeX = Math.cos(node.angle) * (currentAmplitude + node.distance);\n            const nodeY = Math.sin(node.angle) * (currentAmplitude + node.distance);\n            const nodeAlpha = node.intensity * alpha;\n            \n            ctx.fillStyle = this.getResonanceColor(nodeAlpha);\n            ctx.shadowBlur = 8;\n            ctx.shadowColor = this.getResonanceColor(1.0).replace(/[\\d\\.]+\\)/, '1)');\n            \n            ctx.beginPath();\n            ctx.arc(nodeX, nodeY, 2, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        // Central resonance core\n        const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 10);\n        coreGradient.addColorStop(0, this.getResonanceColor(alpha));\n        coreGradient.addColorStop(0.7, this.getResonanceColor(alpha * 0.5));\n        coreGradient.addColorStop(1, 'transparent');\n        \n        ctx.fillStyle = coreGradient;\n        ctx.beginPath();\n        ctx.arc(0, 0, 10, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Resonance frequency indicator\n        if (this.type !== 'normal') {\n            ctx.font = '7px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;\n            ctx.textAlign = 'center';\n            ctx.fillText(`${this.frequency.toFixed(2)}Hz`, 0, this.maxAmplitude + 15);\n        }\n        \n        ctx.restore();\n    }\n    \n    getResonanceColor(alpha, harmonicIndex = 0) {\n        const hue = (harmonicIndex * 60) % 360;\n        \n        switch (this.type) {\n            case 'amplified': return `hsla(${300 + hue}, 80%, 70%, ${alpha})`;\n            case 'harmonic': return `hsla(${180 + hue}, 80%, 70%, ${alpha})`;\n            case 'quantum': return `hsla(${60 + hue}, 80%, 70%, ${alpha})`;\n            case 'spontaneous': return `hsla(${0 + hue}, 80%, 70%, ${alpha})`;\n            default: return `hsla(${120 + hue}, 80%, 70%, ${alpha})`;\n        }\n    }\n}\n\nclass EchoChamber {\n    constructor(x, y, index) {\n        this.x = x;\n        this.y = y;\n        this.index = index;\n        this.active = false;\n        this.activationLevel = 0;\n        this.maxActivation = 100;\n        this.resonanceField = [];\n        this.echoBuffer = [];\n        this.lastEchoTime = 0;\n        this.chamberWalls = [];\n        \n        this.createResonanceField();\n        this.createChamberWalls();\n    }\n    \n    createResonanceField() {\n        for (let i = 0; i < 12; i++) {\n            const angle = (i / 12) * Math.PI * 2;\n            this.resonanceField.push({\n                angle: angle,\n                distance: 40,\n                intensity: 0,\n                phase: 0\n            });\n        }\n    }\n    \n    createChamberWalls() {\n        // Create hexagonal chamber walls\n        for (let i = 0; i < 6; i++) {\n            const angle = (i / 6) * Math.PI * 2;\n            const nextAngle = ((i + 1) / 6) * Math.PI * 2;\n            \n            this.chamberWalls.push({\n                start: {\n                    x: Math.cos(angle) * 30,\n                    y: Math.sin(angle) * 30\n                },\n                end: {\n                    x: Math.cos(nextAngle) * 30,\n                    y: Math.sin(nextAngle) * 30\n                },\n                resonance: 0\n            });\n        }\n    }\n    \n    activate() {\n        this.active = true;\n        this.activationLevel = this.maxActivation;\n    }\n    \n    stabilize() {\n        this.activationLevel = Math.min(this.maxActivation * 0.3, this.activationLevel);\n    }\n    \n    spontaneousActivation() {\n        this.active = true;\n        this.activationLevel = this.maxActivation * 0.6;\n    }\n    \n    receiveEcho(sourceX, sourceY) {\n        // Calculate echo parameters\n        const distance = Math.sqrt(\n            Math.pow(this.x - sourceX, 2) + Math.pow(this.y - sourceY, 2)\n        );\n        \n        const echoStrength = Math.max(0, 100 - distance);\n        \n        this.echoBuffer.push({\n            strength: echoStrength,\n            delay: distance * 0.5,\n            sourceX: sourceX,\n            sourceY: sourceY,\n            life: 60\n        });\n        \n        // Activate chamber\n        this.activationLevel = Math.min(\n            this.maxActivation, \n            this.activationLevel + echoStrength * 0.3\n        );\n        \n        if (this.activationLevel > 30) {\n            this.active = true;\n        }\n    }\n    \n    shouldPropagateEcho(otherChamber) {\n        return this.isActive() && otherChamber.isActive() && \n               Math.random() < 0.1 && \n               Date.now() - this.lastEchoTime > 500;\n    }\n    \n    isActive() {\n        return this.active && this.activationLevel > 10;\n    }\n    \n    update(time, globalIntensity) {\n        // Update echo buffer\n        this.echoBuffer = this.echoBuffer.filter(echo => {\n            echo.delay--;\n            echo.life--;\n            \n            if (echo.delay <= 0 && echo.life > 0) {\n                // Process echo\n                this.processEcho(echo, globalIntensity);\n            }\n            \n            return echo.life > 0;\n        });\n        \n        // Update resonance field\n        this.resonanceField.forEach(field => {\n            field.phase += 0.08;\n            field.intensity = this.activationLevel / this.maxActivation;\n        });\n        \n        // Update chamber walls\n        this.chamberWalls.forEach(wall => {\n            wall.resonance = this.activationLevel / this.maxActivation;\n        });\n        \n        // Activation decay\n        if (this.active) {\n            this.activationLevel *= 0.998;\n            \n            if (this.activationLevel < 5) {\n                this.active = false;\n                this.activationLevel = 0;\n            }\n        }\n    }\n    \n    processEcho(echo, globalIntensity) {\n        // Create visual effects for processed echo\n        const effectIntensity = echo.strength * globalIntensity * 0.01;\n        \n        this.resonanceField.forEach(field => {\n            field.intensity += effectIntensity;\n        });\n        \n        this.lastEchoTime = Date.now();\n    }\n    \n    render(ctx) {\n        const alpha = this.activationLevel / this.maxActivation;\n        \n        ctx.save();\n        ctx.translate(this.x, this.y);\n        \n        // Render chamber walls\n        ctx.strokeStyle = `rgba(100, 255, 255, ${alpha * 0.8})`;\n        ctx.lineWidth = 2;\n        ctx.shadowBlur = this.active ? 8 : 4;\n        ctx.shadowColor = '#64ffff';\n        \n        this.chamberWalls.forEach(wall => {\n            const wallIntensity = wall.resonance * alpha;\n            ctx.strokeStyle = `rgba(100, 255, 255, ${wallIntensity})`;\n            \n            ctx.beginPath();\n            ctx.moveTo(wall.start.x, wall.start.y);\n            ctx.lineTo(wall.end.x, wall.end.y);\n            ctx.stroke();\n        });\n        \n        // Render resonance field\n        this.resonanceField.forEach(field => {\n            const fieldRadius = field.distance + Math.sin(field.phase) * 5;\n            const fieldX = Math.cos(field.angle) * fieldRadius;\n            const fieldY = Math.sin(field.angle) * fieldRadius;\n            const fieldAlpha = field.intensity * alpha;\n            \n            ctx.fillStyle = `rgba(100, 255, 255, ${fieldAlpha})`;\n            ctx.shadowBlur = 6;\n            \n            ctx.beginPath();\n            ctx.arc(fieldX, fieldY, 2, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        // Central chamber core\n        if (this.active) {\n            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);\n            coreGradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);\n            coreGradient.addColorStop(0.7, `rgba(100, 255, 255, ${alpha * 0.7})`);\n            coreGradient.addColorStop(1, 'transparent');\n            \n            ctx.fillStyle = coreGradient;\n            ctx.beginPath();\n            ctx.arc(0, 0, 20, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        \n        // Chamber information\n        ctx.font = '8px monospace';\n        ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;\n        ctx.textAlign = 'center';\n        ctx.fillText(`CHAMBER ${this.index + 1}`, 0, -40);\n        \n        if (this.active) {\n            ctx.fillText(`${Math.round(this.activationLevel)}%`, 0, 50);\n        }\n        \n        ctx.restore();\n    }\n}\n\nclass TimeVortex {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.radius = 0;\n        this.maxRadius = 120;\n        this.finished = false;\n        this.life = 250;\n        this.maxLife = 250;\n        this.rotation = 0;\n        this.spiralArms = [];\n        this.temporalFragments = [];\n        \n        this.createSpiralArms();\n        this.createTemporalFragments();\n    }\n    \n    createSpiralArms() {\n        for (let i = 0; i < 8; i++) {\n            this.spiralArms.push({\n                startAngle: (i / 8) * Math.PI * 2,\n                length: 0,\n                maxLength: this.maxRadius,\n                intensity: 1 - i * 0.1\n            });\n        }\n    }\n    \n    createTemporalFragments() {\n        for (let i = 0; i < 20; i++) {\n            const angle = Math.random() * Math.PI * 2;\n            const distance = Math.random() * this.maxRadius;\n            \n            this.temporalFragments.push({\n                angle: angle,\n                distance: distance,\n                speed: 0.02 + Math.random() * 0.03,\n                size: 1 + Math.random() * 2,\n                life: 100 + Math.random() * 100,\n                maxLife: 100 + Math.random() * 100\n            });\n        }\n    }\n    \n    update(time) {\n        this.rotation += 0.03;\n        \n        // Expand vortex\n        this.radius = Math.min(this.maxRadius, this.radius + 1.5);\n        \n        // Update spiral arms\n        this.spiralArms.forEach(arm => {\n            arm.length = Math.min(arm.maxLength, arm.length + 2);\n        });\n        \n        // Update temporal fragments\n        this.temporalFragments = this.temporalFragments.filter(fragment => {\n            fragment.angle += fragment.speed;\n            fragment.distance -= 0.5; // Spiral inward\n            fragment.life--;\n            \n            // Reset fragment if it reaches center or expires\n            if (fragment.distance < 5 || fragment.life <= 0) {\n                fragment.distance = this.maxRadius;\n                fragment.life = fragment.maxLife;\n                fragment.angle = Math.random() * Math.PI * 2;\n            }\n            \n            return true;\n        });\n        \n        this.life--;\n        if (this.life <= 0) {\n            this.finished = true;\n        }\n    }\n    \n    render(ctx) {\n        const alpha = this.life / this.maxLife;\n        \n        ctx.save();\n        ctx.translate(this.x, this.y);\n        ctx.rotate(this.rotation);\n        \n        // Render spiral arms\n        this.spiralArms.forEach(arm => {\n            ctx.strokeStyle = `rgba(255, 0, 255, ${arm.intensity * alpha})`;\n            ctx.lineWidth = 3;\n            ctx.shadowBlur = 10;\n            ctx.shadowColor = '#ff00ff';\n            \n            ctx.beginPath();\n            for (let r = 0; r < arm.length; r += 5) {\n                const spiralAngle = arm.startAngle + (r / arm.maxLength) * Math.PI * 4;\n                const x = Math.cos(spiralAngle) * r;\n                const y = Math.sin(spiralAngle) * r;\n                \n                if (r === 0) {\n                    ctx.moveTo(x, y);\n                } else {\n                    ctx.lineTo(x, y);\n                }\n            }\n            ctx.stroke();\n        });\n        \n        ctx.restore();\n        \n        // Render temporal fragments (not rotated)\n        ctx.save();\n        ctx.translate(this.x, this.y);\n        \n        this.temporalFragments.forEach(fragment => {\n            const fragmentX = Math.cos(fragment.angle) * fragment.distance;\n            const fragmentY = Math.sin(fragment.angle) * fragment.distance;\n            const fragmentAlpha = (fragment.life / fragment.maxLife) * alpha;\n            \n            ctx.fillStyle = `rgba(255, 255, 0, ${fragmentAlpha})`;\n            ctx.shadowBlur = 5;\n            ctx.shadowColor = '#ffff00';\n            \n            ctx.beginPath();\n            ctx.arc(fragmentX, fragmentY, fragment.size, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        // Central vortex core\n        const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);\n        coreGradient.addColorStop(0, 'rgba(0, 0, 0, 1)');\n        coreGradient.addColorStop(0.7, `rgba(100, 0, 200, ${alpha})`);\n        coreGradient.addColorStop(1, 'transparent');\n        \n        ctx.fillStyle = coreGradient;\n        ctx.beginPath();\n        ctx.arc(0, 0, 30, 0, Math.PI * 2);\n        ctx.fill();\n        \n        ctx.restore();\n    }\n}\n\nclass TemporalFeedback {\n    constructor(x1, y1, x2 = null, y2 = null) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2 || (x1 + (Math.random() - 0.5) * 200);\n        this.y2 = y2 || (y1 + (Math.random() - 0.5) * 200);\n        this.finished = false;\n        this.life = 150;\n        this.maxLife = 150;\n        this.flowDirection = 1;\n        this.feedbackPulses = [];\n        this.intensity = 1.0;\n        \n        this.createFeedbackPulses();\n    }\n    \n    createFeedbackPulses() {\n        for (let i = 0; i < 5; i++) {\n            this.feedbackPulses.push({\n                position: Math.random(),\n                speed: 0.01 + Math.random() * 0.02,\n                size: 2 + Math.random() * 3,\n                intensity: Math.random()\n            });\n        }\n    }\n    \n    update(time) {\n        // Update feedback pulses\n        this.feedbackPulses.forEach(pulse => {\n            pulse.position += pulse.speed * this.flowDirection;\n            \n            // Reset pulse position\n            if (pulse.position > 1) {\n                pulse.position = 0;\n            } else if (pulse.position < 0) {\n                pulse.position = 1;\n            }\n            \n            pulse.intensity += (Math.random() - 0.5) * 0.1;\n            pulse.intensity = Math.max(0.3, Math.min(1.0, pulse.intensity));\n        });\n        \n        // Occasionally reverse flow direction\n        if (Math.random() < 0.02) {\n            this.flowDirection *= -1;\n        }\n        \n        // Intensity fluctuation\n        this.intensity = 0.7 + Math.sin(time * 2) * 0.3;\n        \n        this.life--;\n        if (this.life <= 0) {\n            this.finished = true;\n        }\n    }\n    \n    render(ctx) {\n        const alpha = (this.life / this.maxLife) * this.intensity;\n        \n        ctx.save();\n        \n        // Render feedback connection\n        const gradient = ctx.createLinearGradient(this.x1, this.y1, this.x2, this.y2);\n        gradient.addColorStop(0, `rgba(255, 150, 100, ${alpha * 0.5})`);\n        gradient.addColorStop(0.5, `rgba(255, 100, 150, ${alpha * 0.8})`);\n        gradient.addColorStop(1, `rgba(255, 150, 100, ${alpha * 0.5})`);\n        \n        ctx.strokeStyle = gradient;\n        ctx.lineWidth = 2;\n        ctx.shadowBlur = 6;\n        ctx.shadowColor = '#ff9664';\n        \n        ctx.beginPath();\n        ctx.moveTo(this.x1, this.y1);\n        ctx.lineTo(this.x2, this.y2);\n        ctx.stroke();\n        \n        // Render feedback pulses\n        this.feedbackPulses.forEach(pulse => {\n            const pulseX = this.x1 + (this.x2 - this.x1) * pulse.position;\n            const pulseY = this.y1 + (this.y2 - this.y1) * pulse.position;\n            const pulseAlpha = pulse.intensity * alpha;\n            \n            ctx.fillStyle = `rgba(255, 255, 100, ${pulseAlpha})`;\n            ctx.shadowBlur = 8;\n            ctx.shadowColor = '#ffff64';\n            \n            ctx.beginPath();\n            ctx.arc(pulseX, pulseY, pulse.size, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        ctx.restore();\n    }\n}\n\n// Initialize when DOM loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    new TemporalEchoChamber();\n});