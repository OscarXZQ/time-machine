class Physics3D {
    constructor() {\n        this.canvas = document.createElement('canvas');\n        this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');\n        this.particles = [];\n        this.forces = [];\n        this.constraints = [];\n        this.time = 0;\n        this.gravity = { x: 0, y: 0.05, z: 0 };\n        this.damping = 0.99;\n        \n        this.init();\n        this.createParticleSystem();\n        this.animate();\n    }\n    \n    init() {\n        this.canvas.style.position = 'fixed';\n        this.canvas.style.top = '0';\n        this.canvas.style.left = '0';\n        this.canvas.style.width = '100%';\n        this.canvas.style.height = '100%';\n        this.canvas.style.pointerEvents = 'none';\n        this.canvas.style.zIndex = '250';\n        this.canvas.style.mixBlendMode = 'screen';\n        \n        this.resize();\n        document.body.appendChild(this.canvas);\n        \n        if (!this.gl) {\n            console.warn('WebGL not supported for 3D physics');\n            return;\n        }\n        \n        this.gl.enable(this.gl.DEPTH_TEST);\n        this.gl.enable(this.gl.BLEND);\n        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE);\n    }\n    \n    resize() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n        \n        if (this.gl) {\n            this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        }\n    }\n    \n    createParticleSystem() {\n        // Create quantum field particles\n        for (let i = 0; i < 200; i++) {\n            this.particles.push(new QuantumParticle3D());\n        }\n        \n        // Create energy web nodes\n        for (let i = 0; i < 50; i++) {\n            this.particles.push(new EnergyNode3D());\n        }\n        \n        // Create temporal singularities\n        for (let i = 0; i < 10; i++) {\n            this.particles.push(new TemporalSingularity());\n        }\n        \n        this.createConstraints();\n    }\n    \n    createConstraints() {\n        // Connect nearby particles with springs\n        for (let i = 0; i < this.particles.length; i++) {\n            for (let j = i + 1; j < this.particles.length; j++) {\n                const dist = this.distance(this.particles[i], this.particles[j]);\n                if (dist < 100 && Math.random() < 0.1) {\n                    this.constraints.push(new SpringConstraint(this.particles[i], this.particles[j], dist));\n                }\n            }\n        }\n    }\n    \n    distance(p1, p2) {\n        const dx = p1.position.x - p2.position.x;\n        const dy = p1.position.y - p2.position.y;\n        const dz = p1.position.z - p2.position.z;\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    \n    addForce(force) {\n        this.forces.push(force);\n    }\n    \n    createGravitationalWave(centerX, centerY, intensity = 1.0) {\n        const wave = new GravitationalWave(centerX, centerY, 0, intensity);\n        this.forces.push(wave);\n        \n        // Remove after wave passes\n        setTimeout(() => {\n            const index = this.forces.indexOf(wave);\n            if (index > -1) this.forces.splice(index, 1);\n        }, 3000);\n    }\n    \n    createTemporalVortex(x, y, z, strength = 2.0) {\n        const vortex = new TemporalVortex(x, y, z, strength);\n        this.forces.push(vortex);\n        \n        setTimeout(() => {\n            const index = this.forces.indexOf(vortex);\n            if (index > -1) this.forces.splice(index, 1);\n        }, 5000);\n    }\n    \n    update() {\n        this.time += 0.016;\n        \n        // Apply forces to all particles\n        this.particles.forEach(particle => {\n            // Reset forces\n            particle.force = { x: 0, y: 0, z: 0 };\n            \n            // Apply gravity\n            particle.force.x += this.gravity.x * particle.mass;\n            particle.force.y += this.gravity.y * particle.mass;\n            particle.force.z += this.gravity.z * particle.mass;\n            \n            // Apply external forces\n            this.forces.forEach(force => {\n                force.apply(particle, this.time);\n            });\n        });\n        \n        // Apply constraints\n        this.constraints.forEach(constraint => {\n            constraint.apply();\n        });\n        \n        // Integrate motion\n        this.particles.forEach(particle => {\n            particle.update(this.damping);\n        });\n        \n        // Remove dead particles\n        this.particles = this.particles.filter(p => !p.isDead);\n        \n        // Add new particles occasionally\n        if (Math.random() < 0.02) {\n            this.particles.push(new QuantumParticle3D());\n        }\n    }\n    \n    render() {\n        if (!this.gl) return;\n        \n        this.gl.clearColor(0, 0, 0, 0);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\n        \n        // Project 3D particles to 2D for rendering\n        const ctx = this.canvas.getContext('2d');\n        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        // Sort particles by depth\n        const sortedParticles = this.particles.slice().sort((a, b) => b.position.z - a.position.z);\n        \n        sortedParticles.forEach(particle => {\n            particle.render(ctx, this.canvas.width, this.canvas.height);\n        });\n        \n        // Render constraints\n        this.renderConstraints(ctx);\n    }\n    \n    renderConstraints(ctx) {\n        ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';\n        ctx.lineWidth = 1;\n        \n        this.constraints.forEach(constraint => {\n            const p1 = constraint.p1;\n            const p2 = constraint.p2;\n            \n            // Project 3D to 2D\n            const x1 = (p1.position.x + 200) / 400 * this.canvas.width;\n            const y1 = (p1.position.y + 200) / 400 * this.canvas.height;\n            const x2 = (p2.position.x + 200) / 400 * this.canvas.width;\n            const y2 = (p2.position.y + 200) / 400 * this.canvas.height;\n            \n            if (x1 >= 0 && x1 <= this.canvas.width && y1 >= 0 && y1 <= this.canvas.height &&\n                x2 >= 0 && x2 <= this.canvas.width && y2 >= 0 && y2 <= this.canvas.height) {\n                ctx.beginPath();\n                ctx.moveTo(x1, y1);\n                ctx.lineTo(x2, y2);\n                ctx.stroke();\n            }\n        });\n    }\n    \n    animate() {\n        this.update();\n        this.render();\n        requestAnimationFrame(() => this.animate());\n    }\n}\n\nclass Particle3D {\n    constructor(x = 0, y = 0, z = 0) {\n        this.position = { x, y, z };\n        this.velocity = { x: 0, y: 0, z: 0 };\n        this.force = { x: 0, y: 0, z: 0 };\n        this.mass = 1;\n        this.life = 1000;\n        this.maxLife = 1000;\n        this.isDead = false;\n        this.size = 3;\n        this.color = 'rgba(255, 255, 255, 1)';\n    }\n    \n    update(damping) {\n        // Verlet integration for stability\n        const acceleration = {\n            x: this.force.x / this.mass,\n            y: this.force.y / this.mass,\n            z: this.force.z / this.mass\n        };\n        \n        this.velocity.x += acceleration.x;\n        this.velocity.y += acceleration.y;\n        this.velocity.z += acceleration.z;\n        \n        this.velocity.x *= damping;\n        this.velocity.y *= damping;\n        this.velocity.z *= damping;\n        \n        this.position.x += this.velocity.x;\n        this.position.y += this.velocity.y;\n        this.position.z += this.velocity.z;\n        \n        this.life--;\n        if (this.life <= 0) this.isDead = true;\n    }\n    \n    render(ctx, canvasWidth, canvasHeight) {\n        // Simple 3D to 2D projection\n        const focalLength = 300;\n        const scale = focalLength / (focalLength + this.position.z);\n        \n        const x = (this.position.x * scale + canvasWidth / 2);\n        const y = (this.position.y * scale + canvasHeight / 2);\n        const size = this.size * scale;\n        \n        if (x >= 0 && x <= canvasWidth && y >= 0 && y <= canvasHeight) {\n            const opacity = (this.life / this.maxLife) * scale;\n            \n            ctx.save();\n            ctx.globalAlpha = opacity;\n            ctx.fillStyle = this.color;\n            ctx.shadowBlur = size * 2;\n            ctx.shadowColor = this.color;\n            \n            ctx.beginPath();\n            ctx.arc(x, y, size, 0, Math.PI * 2);\n            ctx.fill();\n            \n            ctx.restore();\n        }\n    }\n}\n\nclass QuantumParticle3D extends Particle3D {\n    constructor() {\n        super(\n            (Math.random() - 0.5) * 400,\n            (Math.random() - 0.5) * 400,\n            (Math.random() - 0.5) * 200\n        );\n        \n        this.velocity = {\n            x: (Math.random() - 0.5) * 2,\n            y: (Math.random() - 0.5) * 2,\n            z: (Math.random() - 0.5) * 1\n        };\n        \n        this.mass = 0.5 + Math.random() * 0.5;\n        this.quantumState = Math.random();\n        this.coherence = Math.random();\n        this.entangled = null;\n        this.size = Math.random() * 3 + 1;\n        \n        this.colors = [\n            'rgba(0, 255, 255, ',\n            'rgba(255, 0, 255, ',\n            'rgba(255, 255, 0, ',\n            'rgba(0, 255, 0, '\n        ];\n        this.baseColor = this.colors[Math.floor(Math.random() * this.colors.length)];\n    }\n    \n    update(damping) {\n        super.update(damping);\n        \n        // Quantum tunneling effect\n        if (Math.random() < 0.001) {\n            this.position.x += (Math.random() - 0.5) * 100;\n            this.position.y += (Math.random() - 0.5) * 100;\n            this.position.z += (Math.random() - 0.5) * 50;\n        }\n        \n        // Wave function collapse\n        this.quantumState = Math.sin(Date.now() * 0.001 + this.position.x * 0.01) * 0.5 + 0.5;\n        \n        // Decoherence over time\n        this.coherence *= 0.9995;\n        \n        if (this.coherence < 0.1) {\n            this.isDead = true;\n        }\n    }\n    \n    render(ctx, canvasWidth, canvasHeight) {\n        const opacity = this.coherence * this.quantumState;\n        this.color = this.baseColor + opacity + ')';\n        \n        super.render(ctx, canvasWidth, canvasHeight);\n        \n        // Quantum interference pattern\n        if (this.coherence > 0.7) {\n            const focalLength = 300;\n            const scale = focalLength / (focalLength + this.position.z);\n            const x = (this.position.x * scale + canvasWidth / 2);\n            const y = (this.position.y * scale + canvasHeight / 2);\n            \n            ctx.save();\n            ctx.globalAlpha = opacity * 0.5;\n            ctx.strokeStyle = this.baseColor + opacity + ')';\n            ctx.lineWidth = 1;\n            \n            for (let i = 1; i <= 3; i++) {\n                ctx.beginPath();\n                ctx.arc(x, y, this.size * scale * i * 2, 0, Math.PI * 2);\n                ctx.stroke();\n            }\n            \n            ctx.restore();\n        }\n    }\n}\n\nclass EnergyNode3D extends Particle3D {\n    constructor() {\n        super(\n            (Math.random() - 0.5) * 300,\n            (Math.random() - 0.5) * 300,\n            (Math.random() - 0.5) * 150\n        );\n        \n        this.mass = 2;\n        this.energy = Math.random() * 100 + 50;\n        this.resonance = Math.random() * 0.1 + 0.05;\n        this.connections = [];\n        this.size = Math.random() * 5 + 3;\n        this.color = 'rgba(255, 150, 0, ';\n        this.life = 2000;\n        this.maxLife = 2000;\n    }\n    \n    update(damping) {\n        super.update(damping);\n        \n        // Energy pulsing\n        this.energy += Math.sin(Date.now() * this.resonance) * 5;\n        this.energy = Math.max(10, Math.min(150, this.energy));\n        \n        // Emit energy particles\n        if (Math.random() < 0.05 && this.energy > 80) {\n            this.emitEnergyBurst();\n            this.energy -= 10;\n        }\n    }\n    \n    emitEnergyBurst() {\n        // This would add new particles to the system\n        // Implementation depends on the main physics system\n    }\n    \n    render(ctx, canvasWidth, canvasHeight) {\n        const intensity = this.energy / 150;\n        this.color = 'rgba(255, ' + Math.floor(150 * intensity) + ', 0, ';\n        \n        super.render(ctx, canvasWidth, canvasHeight);\n        \n        // Energy aura\n        const focalLength = 300;\n        const scale = focalLength / (focalLength + this.position.z);\n        const x = (this.position.x * scale + canvasWidth / 2);\n        const y = (this.position.y * scale + canvasHeight / 2);\n        const auraSize = this.size * scale * intensity * 2;\n        \n        ctx.save();\n        ctx.globalAlpha = intensity * 0.3;\n        \n        const gradient = ctx.createRadialGradient(x, y, 0, x, y, auraSize);\n        gradient.addColorStop(0, this.color + '0.6)');\n        gradient.addColorStop(0.5, this.color + '0.3)');\n        gradient.addColorStop(1, this.color + '0)');\n        \n        ctx.fillStyle = gradient;\n        ctx.beginPath();\n        ctx.arc(x, y, auraSize, 0, Math.PI * 2);\n        ctx.fill();\n        \n        ctx.restore();\n    }\n}\n\nclass TemporalSingularity extends Particle3D {\n    constructor() {\n        super(\n            (Math.random() - 0.5) * 200,\n            (Math.random() - 0.5) * 200,\n            (Math.random() - 0.5) * 100\n        );\n        \n        this.mass = 10;\n        this.eventHorizon = Math.random() * 20 + 15;\n        this.hawkingRadiation = [];\n        this.rotationSpeed = (Math.random() - 0.5) * 0.1;\n        this.rotation = 0;\n        this.size = 8;\n        this.color = 'rgba(0, 0, 0, ';\n        this.life = 5000;\n        this.maxLife = 5000;\n    }\n    \n    update(damping) {\n        // Singularities don't move much but do rotate\n        this.rotation += this.rotationSpeed;\n        \n        // Emit Hawking radiation\n        if (Math.random() < 0.1) {\n            this.emitHawkingRadiation();\n        }\n        \n        this.life--;\n        if (this.life <= 0) this.isDead = true;\n    }\n    \n    emitHawkingRadiation() {\n        // Create radiation particles\n        const angle = Math.random() * Math.PI * 2;\n        const phi = Math.random() * Math.PI;\n        \n        this.hawkingRadiation.push({\n            x: this.position.x + Math.cos(angle) * Math.sin(phi) * this.eventHorizon,\n            y: this.position.y + Math.sin(angle) * Math.sin(phi) * this.eventHorizon,\n            z: this.position.z + Math.cos(phi) * this.eventHorizon,\n            vx: Math.cos(angle) * Math.sin(phi) * 2,\n            vy: Math.sin(angle) * Math.sin(phi) * 2,\n            vz: Math.cos(phi) * 2,\n            life: 100\n        });\n    }\n    \n    render(ctx, canvasWidth, canvasHeight) {\n        const focalLength = 300;\n        const scale = focalLength / (focalLength + this.position.z);\n        const x = (this.position.x * scale + canvasWidth / 2);\n        const y = (this.position.y * scale + canvasHeight / 2);\n        const horizonSize = this.eventHorizon * scale;\n        \n        // Event horizon\n        ctx.save();\n        ctx.globalAlpha = 0.8;\n        \n        const gradient = ctx.createRadialGradient(x, y, 0, x, y, horizonSize);\n        gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');\n        gradient.addColorStop(0.7, 'rgba(50, 0, 100, 0.8)');\n        gradient.addColorStop(1, 'rgba(0, 100, 200, 0)');\n        \n        ctx.fillStyle = gradient;\n        ctx.beginPath();\n        ctx.arc(x, y, horizonSize, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Accretion disk\n        ctx.strokeStyle = 'rgba(255, 150, 0, 0.6)';\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.arc(x, y, horizonSize * 1.5, 0, Math.PI * 2);\n        ctx.stroke();\n        \n        ctx.restore();\n        \n        // Render Hawking radiation\n        this.hawkingRadiation = this.hawkingRadiation.filter(radiation => {\n            radiation.x += radiation.vx;\n            radiation.y += radiation.vy;\n            radiation.z += radiation.vz;\n            radiation.life--;\n            \n            if (radiation.life > 0) {\n                const radScale = focalLength / (focalLength + radiation.z);\n                const radX = (radiation.x * radScale + canvasWidth / 2);\n                const radY = (radiation.y * radScale + canvasHeight / 2);\n                \n                ctx.save();\n                ctx.globalAlpha = radiation.life / 100 * 0.8;\n                ctx.fillStyle = 'rgba(255, 255, 255, 1)';\n                ctx.beginPath();\n                ctx.arc(radX, radY, 1 * radScale, 0, Math.PI * 2);\n                ctx.fill();\n                ctx.restore();\n                \n                return true;\n            }\n            return false;\n        });\n    }\n}\n\nclass SpringConstraint {\n    constructor(p1, p2, restLength, stiffness = 0.1) {\n        this.p1 = p1;\n        this.p2 = p2;\n        this.restLength = restLength;\n        this.stiffness = stiffness;\n        this.damping = 0.9;\n    }\n    \n    apply() {\n        const dx = this.p2.position.x - this.p1.position.x;\n        const dy = this.p2.position.y - this.p1.position.y;\n        const dz = this.p2.position.z - this.p1.position.z;\n        \n        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        const force = (distance - this.restLength) * this.stiffness;\n        \n        if (distance > 0) {\n            const fx = (dx / distance) * force;\n            const fy = (dy / distance) * force;\n            const fz = (dz / distance) * force;\n            \n            this.p1.force.x += fx;\n            this.p1.force.y += fy;\n            this.p1.force.z += fz;\n            \n            this.p2.force.x -= fx;\n            this.p2.force.y -= fy;\n            this.p2.force.z -= fz;\n        }\n    }\n}\n\nclass GravitationalWave {\n    constructor(x, y, z, intensity) {\n        this.center = { x, y, z };\n        this.intensity = intensity;\n        this.radius = 0;\n        this.maxRadius = 500;\n        this.speed = 5;\n    }\n    \n    apply(particle, time) {\n        const dx = particle.position.x - this.center.x;\n        const dy = particle.position.y - this.center.y;\n        const dz = particle.position.z - this.center.z;\n        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        // Wave effect - only affects particles at the wave front\n        if (Math.abs(distance - this.radius) < 20) {\n            const waveForce = this.intensity * Math.sin(time * 10) / (distance + 1);\n            \n            if (distance > 0) {\n                particle.force.x += (dx / distance) * waveForce;\n                particle.force.y += (dy / distance) * waveForce;\n                particle.force.z += (dz / distance) * waveForce;\n            }\n        }\n        \n        this.radius += this.speed;\n    }\n}\n\nclass TemporalVortex {\n    constructor(x, y, z, strength) {\n        this.center = { x, y, z };\n        this.strength = strength;\n        this.radius = 150;\n        this.rotationSpeed = 0.1;\n    }\n    \n    apply(particle, time) {\n        const dx = particle.position.x - this.center.x;\n        const dy = particle.position.y - this.center.y;\n        const dz = particle.position.z - this.center.z;\n        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        if (distance < this.radius && distance > 0) {\n            // Spiral force\n            const force = this.strength / (distance * distance + 1);\n            \n            // Tangential component (rotation)\n            const tangentX = -dy;\n            const tangentY = dx;\n            \n            // Radial component (inward pull)\n            const radialX = -dx / distance;\n            const radialY = -dy / distance;\n            const radialZ = -dz / distance;\n            \n            particle.force.x += (tangentX * this.rotationSpeed + radialX * 0.5) * force;\n            particle.force.y += (tangentY * this.rotationSpeed + radialY * 0.5) * force;\n            particle.force.z += radialZ * force * 0.2;\n        }\n    }\n}\n\n// Initialize when DOM loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    const physics3d = new Physics3D();\n    \n    // Bind physics events\n    document.addEventListener('travel-start', () => {\n        physics3d.createGravitationalWave(\n            window.innerWidth / 2,\n            window.innerHeight / 2,\n            2.0\n        );\n        \n        physics3d.createTemporalVortex(\n            0, 0, 0, 3.0\n        );\n    });\n    \n    document.addEventListener('calibrate-start', () => {\n        physics3d.createGravitationalWave(\n            window.innerWidth / 2,\n            window.innerHeight / 2,\n            1.0\n        );\n    });\n    \n    document.addEventListener('click', (e) => {\n        if (Math.random() < 0.3) {\n            physics3d.createTemporalVortex(\n                e.clientX - window.innerWidth / 2,\n                e.clientY - window.innerHeight / 2,\n                0,\n                1.5\n            );\n        }\n    });\n    \n    window.addEventListener('resize', () => {\n        physics3d.resize();\n    });\n});