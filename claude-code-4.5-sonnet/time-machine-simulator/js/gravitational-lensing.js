class GravitationalLensingSystem {
    constructor() {
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.massiveBodies = [];
        this.lightRays = [];
        this.lensingEffects = [];
        this.einsteinRings = [];
        this.virtualImages = [];
        this.time = 0;
        this.lensingStrength = 1.0;
        this.lightDeflectionEvents = [];
        
        this.init();
        this.createLensingSystems();
        this.animate();
    }
    
    init() {
        this.canvas.style.position = 'fixed';
        this.canvas.style.top = '0';
        this.canvas.style.left = '0';
        this.canvas.style.width = '100%';
        this.canvas.style.height = '100%';
        this.canvas.style.pointerEvents = 'none';
        this.canvas.style.zIndex = '490';
        this.canvas.style.mixBlendMode = 'screen';
        this.canvas.style.opacity = '0.7';
        
        this.resize();
        document.body.appendChild(this.canvas);
        
        this.bindEvents();
    }
    
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.createLensingSystems();
    }
    
    bindEvents() {
        document.addEventListener('travel-start', () => {
            this.createMassiveLensingEvent();
            this.amplifyLensing();
        });
        
        document.addEventListener('calibrate-start', () => {
            this.stabilizeLensing();
        });
        
        document.addEventListener('mousemove', (e) => {
            this.createLocalLensingEffect(e.clientX, e.clientY);
        });
    }
    \n    createLensingSystems() {\n        this.massiveBodies = [];\n        this.einsteinRings = [];\n        \n        // Create massive gravitational lenses\n        const centerX = this.canvas.width / 2;\n        const centerY = this.canvas.height / 2;\n        \n        // Primary lens at center\n        this.massiveBodies.push(new GravitationalLens(\n            centerX, centerY, 100, 'primary'\n        ));\n        \n        // Secondary lenses around the primary\n        for (let i = 0; i < 4; i++) {\n            const angle = (i / 4) * Math.PI * 2;\n            const distance = 200;\n            this.massiveBodies.push(new GravitationalLens(\n                centerX + Math.cos(angle) * distance,\n                centerY + Math.sin(angle) * distance,\n                50,\n                'secondary'\n            ));\n        }\n        \n        // Create Einstein rings\n        this.createEinsteinRings();\n        \n        // Create initial light rays\n        this.createLightRays();\n        \n        // Create lensing effects\n        this.createLensingEffects();\n    }\n    \n    createEinsteinRings() {\n        this.massiveBodies.forEach(body => {\n            if (body.mass > 50) {\n                this.einsteinRings.push(new EinsteinRing(\n                    body.x, body.y, body.mass\n                ));\n            }\n        });\n    }\n    \n    createLightRays() {\n        // Create light rays from various angles\n        for (let i = 0; i < 30; i++) {\n            const angle = (i / 30) * Math.PI * 2;\n            const distance = 400;\n            const centerX = this.canvas.width / 2;\n            const centerY = this.canvas.height / 2;\n            \n            this.lightRays.push(new LightRay(\n                centerX + Math.cos(angle) * distance,\n                centerY + Math.sin(angle) * distance,\n                angle + Math.PI // pointing toward center\n            ));\n        }\n    }\n    \n    createLensingEffects() {\n        for (let i = 0; i < 8; i++) {\n            this.lensingEffects.push(new LensingEffect(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height\n            ));\n        }\n    }\n    \n    createMassiveLensingEvent() {\n        // Create a massive gravitational lens during time travel\n        this.massiveBodies.push(new GravitationalLens(\n            this.canvas.width / 2,\n            this.canvas.height / 2,\n            150,\n            'massive'\n        ));\n        \n        // Create corresponding Einstein ring\n        this.einsteinRings.push(new EinsteinRing(\n            this.canvas.width / 2,\n            this.canvas.height / 2,\n            150\n        ));\n        \n        // Create multiple virtual images\n        for (let i = 0; i < 6; i++) {\n            const angle = (i / 6) * Math.PI * 2;\n            const distance = 120;\n            this.virtualImages.push(new VirtualImage(\n                this.canvas.width / 2 + Math.cos(angle) * distance,\n                this.canvas.height / 2 + Math.sin(angle) * distance\n            ));\n        }\n    }\n    \n    amplifyLensing() {\n        this.lensingStrength = 3.0;\n        \n        // Amplify all existing lenses\n        this.massiveBodies.forEach(body => body.amplify());\n        this.einsteinRings.forEach(ring => ring.intensify());\n        \n        // Create more light rays\n        for (let i = 0; i < 20; i++) {\n            this.lightRays.push(new LightRay(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height,\n                Math.random() * Math.PI * 2,\n                'enhanced'\n            ));\n        }\n    }\n    \n    stabilizeLensing() {\n        this.lensingStrength = 1.0;\n        this.massiveBodies.forEach(body => body.stabilize());\n    }\n    \n    createLocalLensingEffect(x, y) {\n        if (Math.random() < 0.08) {\n            this.lensingEffects.push(new LensingEffect(x, y, 'interactive'));\n            \n            // Create deflection event\n            this.lightDeflectionEvents.push(new LightDeflection(x, y));\n        }\n    }\n    \n    update() {\n        this.time += 0.016;\n        \n        // Update all systems\n        this.massiveBodies.forEach(body => body.update(this.time));\n        \n        this.lightRays = this.lightRays.filter(ray => {\n            // Apply gravitational lensing to light rays\n            this.applyGravitationalLensing(ray);\n            ray.update(this.time);\n            return !ray.finished;\n        });\n        \n        this.einsteinRings.forEach(ring => ring.update(this.time, this.lensingStrength));\n        \n        this.lensingEffects = this.lensingEffects.filter(effect => {\n            effect.update(this.time);\n            return !effect.finished;\n        });\n        \n        this.virtualImages = this.virtualImages.filter(image => {\n            image.update(this.time);\n            return !image.finished;\n        });\n        \n        this.lightDeflectionEvents = this.lightDeflectionEvents.filter(event => {\n            event.update(this.time);\n            return !event.finished;\n        });\n        \n        // Lensing strength decay\n        this.lensingStrength = Math.max(1.0, this.lensingStrength * 0.999);\n        \n        // Spontaneous lensing events\n        if (Math.random() < 0.005) {\n            this.createSpontaneousLensing();\n        }\n    }\n    \n    applyGravitationalLensing(lightRay) {\n        this.massiveBodies.forEach(body => {\n            const dx = lightRay.x - body.x;\n            const dy = lightRay.y - body.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            \n            if (distance < body.influenceRadius && distance > 0) {\n                // Calculate light deflection based on mass and distance\n                const deflectionStrength = (body.mass * this.lensingStrength) / (distance * distance);\n                const maxDeflection = 0.1; // Limit maximum deflection\n                const actualDeflection = Math.min(deflectionStrength * 0.001, maxDeflection);\n                \n                // Deflect light ray perpendicular to the radial direction\n                const perpAngle = Math.atan2(dy, dx) + Math.PI / 2;\n                lightRay.vx += Math.cos(perpAngle) * actualDeflection;\n                lightRay.vy += Math.sin(perpAngle) * actualDeflection;\n                \n                // Create deflection visual effect\n                if (Math.random() < 0.1) {\n                    this.lightDeflectionEvents.push(new LightDeflection(\n                        lightRay.x, lightRay.y\n                    ));\n                }\n            }\n        });\n    }\n    \n    createSpontaneousLensing() {\n        const eventType = Math.random();\n        \n        if (eventType < 0.3) {\n            // Micro-lensing event\n            this.massiveBodies.push(new GravitationalLens(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height,\n                20,\n                'micro'\n            ));\n        } else if (eventType < 0.6) {\n            // Lensing effect\n            this.lensingEffects.push(new LensingEffect(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height,\n                'spontaneous'\n            ));\n        } else {\n            // Virtual image\n            this.virtualImages.push(new VirtualImage(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height\n            ));\n        }\n    }\n    \n    render() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        // Render lensing effects (background)\n        this.lensingEffects.forEach(effect => effect.render(this.ctx));\n        \n        // Render light rays\n        this.lightRays.forEach(ray => ray.render(this.ctx));\n        \n        // Render Einstein rings\n        this.einsteinRings.forEach(ring => ring.render(this.ctx));\n        \n        // Render massive bodies\n        this.massiveBodies.forEach(body => body.render(this.ctx));\n        \n        // Render virtual images\n        this.virtualImages.forEach(image => image.render(this.ctx));\n        \n        // Render light deflection events\n        this.lightDeflectionEvents.forEach(event => event.render(this.ctx));\n        \n        // Render lensing statistics\n        this.renderLensingStats();\n    }\n    \n    renderLensingStats() {\n        this.ctx.save();\n        this.ctx.font = '11px monospace';\n        this.ctx.fillStyle = 'rgba(255, 200, 100, 0.8)';\n        \n        const activeLenses = this.massiveBodies.length;\n        const lightRayCount = this.lightRays.length;\n        const einsteinRingCount = this.einsteinRings.length;\n        const virtualImageCount = this.virtualImages.length;\n        \n        this.ctx.fillText(`Lensing Strength: ${this.lensingStrength.toFixed(1)}x`, this.canvas.width - 250, 30);\n        this.ctx.fillText(`Active Lenses: ${activeLenses}`, this.canvas.width - 250, 50);\n        this.ctx.fillText(`Light Rays: ${lightRayCount}`, this.canvas.width - 250, 70);\n        this.ctx.fillText(`Einstein Rings: ${einsteinRingCount}`, this.canvas.width - 250, 90);\n        this.ctx.fillText(`Virtual Images: ${virtualImageCount}`, this.canvas.width - 250, 110);\n        \n        this.ctx.restore();\n    }\n    \n    animate() {\n        this.update();\n        this.render();\n        requestAnimationFrame(() => this.animate());\n    }\n}\n\nclass GravitationalLens {\n    constructor(x, y, mass, type = 'normal') {\n        this.x = x;\n        this.y = y;\n        this.mass = mass;\n        this.type = type;\n        this.baseMass = mass;\n        this.influenceRadius = mass * 3;\n        this.schwarzschildRadius = mass * 0.1;\n        this.active = true;\n        this.life = type === 'micro' ? 200 : 1000;\n        this.maxLife = this.life;\n        this.gravityWaves = [];\n        this.massDensity = 1.0;\n        \n        this.createGravityWaves();\n    }\n    \n    createGravityWaves() {\n        for (let i = 0; i < 8; i++) {\n            this.gravityWaves.push({\n                radius: 0,\n                speed: 1 + i * 0.3,\n                maxRadius: this.influenceRadius + i * 20,\n                intensity: 1 - i * 0.1\n            });\n        }\n    }\n    \n    amplify() {\n        this.mass = this.baseMass * 2;\n        this.influenceRadius = this.mass * 3;\n        this.massDensity = 2.0;\n    }\n    \n    stabilize() {\n        this.mass = this.baseMass;\n        this.massDensity = 1.0;\n    }\n    \n    update(time) {\n        // Update gravity waves\n        this.gravityWaves.forEach(wave => {\n            wave.radius += wave.speed;\n            if (wave.radius > wave.maxRadius) {\n                wave.radius = 0;\n            }\n        });\n        \n        // Mass pulsation for massive lenses\n        if (this.type === 'massive') {\n            this.mass = this.baseMass + Math.sin(time * 2) * 20;\n            this.influenceRadius = this.mass * 3;\n        }\n        \n        // Decay for temporary lenses\n        if (this.type === 'micro' || this.type === 'interactive') {\n            this.life--;\n            if (this.life <= 0) {\n                this.active = false;\n            }\n        }\n    }\n    \n    render(ctx) {\n        if (!this.active) return;\n        \n        const alpha = this.type === 'micro' ? (this.life / this.maxLife) : 1.0;\n        \n        ctx.save();\n        ctx.translate(this.x, this.y);\n        \n        // Render gravity waves\n        this.gravityWaves.forEach(wave => {\n            if (wave.radius > 0 && wave.radius <= wave.maxRadius) {\n                const waveAlpha = (1 - wave.radius / wave.maxRadius) * wave.intensity * alpha * 0.4;\n                \n                ctx.strokeStyle = `rgba(255, 200, 100, ${waveAlpha})`;\n                ctx.lineWidth = 1;\n                \n                ctx.beginPath();\n                ctx.arc(0, 0, wave.radius, 0, Math.PI * 2);\n                ctx.stroke();\n            }\n        });\n        \n        // Render event horizon\n        if (this.schwarzschildRadius > 0) {\n            ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.8})`;\n            ctx.strokeStyle = `rgba(255, 150, 0, ${alpha})`;\n            ctx.lineWidth = 2;\n            \n            ctx.beginPath();\n            ctx.arc(0, 0, this.schwarzschildRadius, 0, Math.PI * 2);\n            ctx.fill();\n            ctx.stroke();\n        }\n        \n        // Render lens core\n        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.mass * 0.5);\n        gradient.addColorStop(0, `rgba(255, 255, 200, ${alpha * this.massDensity})`);\n        gradient.addColorStop(0.7, `rgba(255, 200, 100, ${alpha * this.massDensity * 0.7})`);\n        gradient.addColorStop(1, 'transparent');\n        \n        ctx.fillStyle = gradient;\n        ctx.beginPath();\n        ctx.arc(0, 0, this.mass * 0.5, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Lens information\n        if (this.type !== 'normal') {\n            ctx.font = '9px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;\n            ctx.textAlign = 'center';\n            ctx.fillText(this.type.toUpperCase(), 0, -this.mass * 0.5 - 10);\n            ctx.fillText(`M: ${Math.round(this.mass)}`, 0, -this.mass * 0.5 + 5);\n        }\n        \n        ctx.restore();\n    }\n}\n\nclass LightRay {\n    constructor(x, y, direction, type = 'normal') {\n        this.x = x;\n        this.y = y;\n        this.direction = direction;\n        this.type = type;\n        this.vx = Math.cos(direction) * 2;\n        this.vy = Math.sin(direction) * 2;\n        this.speed = 2;\n        this.wavelength = type === 'enhanced' ? 400 + Math.random() * 300 : 550; // nm\n        this.intensity = type === 'enhanced' ? 1.0 : 0.7;\n        this.trail = [];\n        this.maxTrailLength = 15;\n        this.finished = false;\n        this.life = type === 'enhanced' ? 400 : 300;\n        this.maxLife = this.life;\n        this.deflectionCount = 0;\n        this.redshift = 0;\n    }\n    \n    update(time) {\n        // Add current position to trail\n        this.trail.push({ \n            x: this.x, \n            y: this.y, \n            intensity: this.intensity,\n            wavelength: this.wavelength\n        });\n        if (this.trail.length > this.maxTrailLength) {\n            this.trail.shift();\n        }\n        \n        // Movement\n        this.x += this.vx;\n        this.y += this.vy;\n        \n        // Apply redshift based on deflections\n        this.redshift = this.deflectionCount * 10;\n        this.wavelength = Math.min(700, this.wavelength + this.redshift);\n        \n        // Boundary handling\n        if (this.x < -50 || this.x > window.innerWidth + 50 || \n            this.y < -50 || this.y > window.innerHeight + 50) {\n            this.finished = true;\n        }\n        \n        this.life--;\n        if (this.life <= 0) {\n            this.finished = true;\n        }\n    }\n    \n    render(ctx) {\n        const alpha = (this.life / this.maxLife) * this.intensity;\n        const color = this.wavelengthToRGB(this.wavelength);\n        \n        // Render trail\n        this.trail.forEach((point, index) => {\n            const trailAlpha = (index / this.trail.length) * alpha * 0.6;\n            const trailColor = this.wavelengthToRGB(point.wavelength);\n            \n            ctx.fillStyle = `rgba(${trailColor.r}, ${trailColor.g}, ${trailColor.b}, ${trailAlpha})`;\n            ctx.beginPath();\n            ctx.arc(point.x, point.y, 1, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        // Render main ray\n        ctx.save();\n        ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;\n        ctx.shadowBlur = 8;\n        ctx.shadowColor = `rgb(${color.r}, ${color.g}, ${color.b})`;\n        \n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.type === 'enhanced' ? 2.5 : 1.5, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Deflection indicator\n        if (this.deflectionCount > 0) {\n            ctx.font = '8px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.7})`;\n            ctx.textAlign = 'center';\n            ctx.fillText(`D:${this.deflectionCount}`, this.x, this.y - 8);\n        }\n        \n        ctx.restore();\n    }\n    \n    wavelengthToRGB(wavelength) {\n        // Convert wavelength to RGB color\n        let r, g, b;\n        \n        if (wavelength < 440) {\n            r = -(wavelength - 440) / (440 - 380);\n            g = 0;\n            b = 1;\n        } else if (wavelength < 490) {\n            r = 0;\n            g = (wavelength - 440) / (490 - 440);\n            b = 1;\n        } else if (wavelength < 510) {\n            r = 0;\n            g = 1;\n            b = -(wavelength - 510) / (510 - 490);\n        } else if (wavelength < 580) {\n            r = (wavelength - 510) / (580 - 510);\n            g = 1;\n            b = 0;\n        } else if (wavelength < 645) {\n            r = 1;\n            g = -(wavelength - 645) / (645 - 580);\n            b = 0;\n        } else {\n            r = 1;\n            g = 0;\n            b = 0;\n        }\n        \n        // Normalize and scale\n        return {\n            r: Math.round(r * 255),\n            g: Math.round(g * 255),\n            b: Math.round(b * 255)\n        };\n    }\n}\n\nclass EinsteinRing {\n    constructor(x, y, mass) {\n        this.x = x;\n        this.y = y;\n        this.mass = mass;\n        this.radius = Math.sqrt(mass) * 8; // Einstein radius approximation\n        this.thickness = 3;\n        this.intensity = 0.5;\n        this.maxIntensity = 1.0;\n        this.oscillation = 0;\n        this.segments = [];\n        this.photonSphere = [];\n        \n        this.createRingSegments();\n        this.createPhotonSphere();\n    }\n    \n    createRingSegments() {\n        for (let i = 0; i < 32; i++) {\n            const angle = (i / 32) * Math.PI * 2;\n            this.segments.push({\n                angle: angle,\n                brightness: 0.5 + Math.random() * 0.5,\n                phase: Math.random() * Math.PI * 2\n            });\n        }\n    }\n    \n    createPhotonSphere() {\n        for (let i = 0; i < 16; i++) {\n            const angle = (i / 16) * Math.PI * 2;\n            this.photonSphere.push({\n                angle: angle,\n                distance: this.radius * 1.5,\n                intensity: Math.random(),\n                speed: 0.02 + Math.random() * 0.03\n            });\n        }\n    }\n    \n    intensify() {\n        this.intensity = this.maxIntensity;\n    }\n    \n    update(time, lensingStrength) {\n        this.oscillation += 0.02;\n        this.intensity = 0.5 + Math.sin(this.oscillation) * 0.3 * lensingStrength;\n        \n        // Update ring segments\n        this.segments.forEach(segment => {\n            segment.phase += 0.03;\n            segment.brightness = 0.5 + Math.sin(segment.phase) * 0.3;\n        });\n        \n        // Update photon sphere\n        this.photonSphere.forEach(photon => {\n            photon.angle += photon.speed;\n            photon.intensity += (Math.random() - 0.5) * 0.1;\n            photon.intensity = Math.max(0.3, Math.min(1.0, photon.intensity));\n        });\n    }\n    \n    render(ctx) {\n        ctx.save();\n        ctx.translate(this.x, this.y);\n        \n        // Render photon sphere\n        this.photonSphere.forEach(photon => {\n            const x = Math.cos(photon.angle) * photon.distance;\n            const y = Math.sin(photon.angle) * photon.distance;\n            \n            ctx.fillStyle = `rgba(255, 255, 255, ${photon.intensity * this.intensity})`;\n            ctx.shadowBlur = 5;\n            ctx.shadowColor = '#ffffff';\n            \n            ctx.beginPath();\n            ctx.arc(x, y, 1.5, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        // Render Einstein ring segments\n        this.segments.forEach(segment => {\n            const startAngle = segment.angle - 0.05;\n            const endAngle = segment.angle + 0.05;\n            const segmentIntensity = segment.brightness * this.intensity;\n            \n            ctx.strokeStyle = `rgba(255, 255, 200, ${segmentIntensity})`;\n            ctx.lineWidth = this.thickness;\n            ctx.shadowBlur = 10;\n            ctx.shadowColor = '#ffffc8';\n            \n            ctx.beginPath();\n            ctx.arc(0, 0, this.radius, startAngle, endAngle);\n            ctx.stroke();\n        });\n        \n        // Ring label\n        ctx.font = '9px monospace';\n        ctx.fillStyle = `rgba(255, 255, 255, ${this.intensity * 0.8})`;\n        ctx.textAlign = 'center';\n        ctx.fillText('EINSTEIN RING', 0, this.radius + 20);\n        \n        ctx.restore();\n    }\n}\n\nclass LensingEffect {\n    constructor(x, y, type = 'normal') {\n        this.x = x;\n        this.y = y;\n        this.type = type;\n        this.radius = 0;\n        this.maxRadius = type === 'interactive' ? 60 : 40;\n        this.finished = false;\n        this.life = type === 'interactive' ? 120 : 200;\n        this.maxLife = this.life;\n        this.distortionRings = [];\n        this.magnification = 1.0;\n        this.causticLines = [];\n        \n        this.createDistortionRings();\n        this.createCausticLines();\n    }\n    \n    createDistortionRings() {\n        for (let i = 0; i < 4; i++) {\n            this.distortionRings.push({\n                radius: 0,\n                maxRadius: this.maxRadius + i * 10,\n                speed: 1 + i * 0.2,\n                distortion: 1 + i * 0.3\n            });\n        }\n    }\n    \n    createCausticLines() {\n        for (let i = 0; i < 6; i++) {\n            const angle = (i / 6) * Math.PI * 2;\n            this.causticLines.push({\n                angle: angle,\n                length: 0,\n                maxLength: 30,\n                intensity: 1.0\n            });\n        }\n    }\n    \n    update(time) {\n        // Expand effect\n        this.radius = Math.min(this.maxRadius, this.radius + 1);\n        \n        // Update distortion rings\n        this.distortionRings.forEach(ring => {\n            ring.radius += ring.speed;\n            if (ring.radius > ring.maxRadius) {\n                ring.radius = 0;\n            }\n        });\n        \n        // Update caustic lines\n        this.causticLines.forEach(line => {\n            if (this.life > this.maxLife * 0.5) {\n                line.length = Math.min(line.maxLength, line.length + 0.5);\n            } else {\n                line.length *= 0.95;\n            }\n        });\n        \n        // Update magnification\n        this.magnification = 1 + Math.sin(time * 3) * 0.3;\n        \n        this.life--;\n        if (this.life <= 0) {\n            this.finished = true;\n        }\n    }\n    \n    render(ctx) {\n        const alpha = this.life / this.maxLife;\n        \n        ctx.save();\n        ctx.translate(this.x, this.y);\n        \n        // Render distortion rings\n        this.distortionRings.forEach(ring => {\n            if (ring.radius > 0 && ring.radius <= ring.maxRadius) {\n                const ringAlpha = (1 - ring.radius / ring.maxRadius) * alpha * 0.6;\n                \n                ctx.save();\n                ctx.scale(ring.distortion, 1 / ring.distortion);\n                \n                ctx.strokeStyle = `rgba(200, 255, 255, ${ringAlpha})`;\n                ctx.lineWidth = 1;\n                ctx.shadowBlur = 5;\n                ctx.shadowColor = '#c8ffff';\n                \n                ctx.beginPath();\n                ctx.arc(0, 0, ring.radius / ring.distortion, 0, Math.PI * 2);\n                ctx.stroke();\n                \n                ctx.restore();\n            }\n        });\n        \n        // Render caustic lines\n        this.causticLines.forEach(line => {\n            if (line.length > 0) {\n                const x1 = Math.cos(line.angle) * 5;\n                const y1 = Math.sin(line.angle) * 5;\n                const x2 = Math.cos(line.angle) * (5 + line.length);\n                const y2 = Math.sin(line.angle) * (5 + line.length);\n                \n                ctx.strokeStyle = `rgba(255, 255, 255, ${line.intensity * alpha})`;\n                ctx.lineWidth = 2;\n                ctx.shadowBlur = 8;\n                ctx.shadowColor = '#ffffff';\n                \n                ctx.beginPath();\n                ctx.moveTo(x1, y1);\n                ctx.lineTo(x2, y2);\n                ctx.stroke();\n            }\n        });\n        \n        // Central lensing core\n        const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 10);\n        coreGradient.addColorStop(0, `rgba(255, 255, 255, ${alpha * 0.8})`);\n        coreGradient.addColorStop(0.7, `rgba(200, 255, 255, ${alpha * 0.5})`);\n        coreGradient.addColorStop(1, 'transparent');\n        \n        ctx.fillStyle = coreGradient;\n        ctx.beginPath();\n        ctx.arc(0, 0, 10 * this.magnification, 0, Math.PI * 2);\n        ctx.fill();\n        \n        ctx.restore();\n    }\n}\n\nclass VirtualImage {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.brightness = 0;\n        this.maxBrightness = 1.0;\n        this.finished = false;\n        this.life = 150;\n        this.maxLife = 150;\n        this.shimmer = 0;\n        this.imageFragments = [];\n        this.coherence = 1.0;\n        \n        this.createImageFragments();\n    }\n    \n    createImageFragments() {\n        for (let i = 0; i < 8; i++) {\n            const angle = (i / 8) * Math.PI * 2;\n            const distance = 10 + Math.random() * 10;\n            \n            this.imageFragments.push({\n                x: Math.cos(angle) * distance,\n                y: Math.sin(angle) * distance,\n                size: 2 + Math.random() * 3,\n                intensity: Math.random(),\n                phase: Math.random() * Math.PI * 2\n            });\n        }\n    }\n    \n    update(time) {\n        this.shimmer += 0.1;\n        \n        // Brightness pulsation\n        if (this.life > this.maxLife * 0.7) {\n            this.brightness = Math.min(this.maxBrightness, this.brightness + 0.05);\n        } else {\n            this.brightness *= 0.95;\n        }\n        \n        // Update image fragments\n        this.imageFragments.forEach(fragment => {\n            fragment.phase += 0.05;\n            fragment.intensity = 0.5 + Math.sin(fragment.phase + this.shimmer) * 0.5;\n        });\n        \n        // Coherence degradation\n        this.coherence *= 0.998;\n        \n        this.life--;\n        if (this.life <= 0) {\n            this.finished = true;\n        }\n    }\n    \n    render(ctx) {\n        const alpha = (this.life / this.maxLife) * this.brightness;\n        \n        ctx.save();\n        ctx.translate(this.x, this.y);\n        \n        // Render image fragments\n        this.imageFragments.forEach(fragment => {\n            const fragmentAlpha = fragment.intensity * alpha * this.coherence;\n            const size = fragment.size * (0.8 + Math.sin(this.shimmer * 2) * 0.2);\n            \n            ctx.fillStyle = `rgba(255, 255, 180, ${fragmentAlpha})`;\n            ctx.shadowBlur = 8;\n            ctx.shadowColor = '#ffffb4';\n            \n            ctx.beginPath();\n            ctx.arc(fragment.x, fragment.y, size, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        // Image coherence indicator\n        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;\n        ctx.lineWidth = 1;\n        ctx.setLineDash([2, 2]);\n        \n        ctx.beginPath();\n        ctx.arc(0, 0, 20, 0, Math.PI * 2);\n        ctx.stroke();\n        ctx.setLineDash([]);\n        \n        // Virtual image label\n        ctx.font = '8px monospace';\n        ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;\n        ctx.textAlign = 'center';\n        ctx.fillText('VIRTUAL', 0, 30);\n        \n        ctx.restore();\n    }\n}\n\nclass LightDeflection {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.radius = 0;\n        this.maxRadius = 30;\n        this.finished = false;\n        this.life = 40;\n        this.maxLife = 40;\n        this.deflectionWaves = [];\n        \n        this.createDeflectionWaves();\n    }\n    \n    createDeflectionWaves() {\n        for (let i = 0; i < 3; i++) {\n            this.deflectionWaves.push({\n                radius: 0,\n                speed: 1.5 + i * 0.5,\n                maxRadius: this.maxRadius + i * 8,\n                intensity: 1 - i * 0.25\n            });\n        }\n    }\n    \n    update(time) {\n        // Update deflection waves\n        this.deflectionWaves.forEach(wave => {\n            wave.radius += wave.speed;\n        });\n        \n        this.life--;\n        if (this.life <= 0) {\n            this.finished = true;\n        }\n    }\n    \n    render(ctx) {\n        const alpha = this.life / this.maxLife;\n        \n        ctx.save();\n        \n        // Render deflection waves\n        this.deflectionWaves.forEach(wave => {\n            if (wave.radius <= wave.maxRadius) {\n                const waveAlpha = (1 - wave.radius / wave.maxRadius) * wave.intensity * alpha;\n                \n                ctx.strokeStyle = `rgba(255, 255, 100, ${waveAlpha})`;\n                ctx.lineWidth = 1;\n                ctx.shadowBlur = 4;\n                ctx.shadowColor = '#ffff64';\n                \n                ctx.beginPath();\n                ctx.arc(this.x, this.y, wave.radius, 0, Math.PI * 2);\n                ctx.stroke();\n            }\n        });\n        \n        // Central deflection point\n        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;\n        ctx.shadowBlur = 6;\n        ctx.shadowColor = '#ffffff';\n        \n        ctx.beginPath();\n        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);\n        ctx.fill();\n        \n        ctx.restore();\n    }\n}\n\n// Initialize when DOM loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    new GravitationalLensingSystem();\n});