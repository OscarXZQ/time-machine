class FractalEngine {\n    constructor() {\n        this.canvas = document.createElement('canvas');\n        this.ctx = this.canvas.getContext('2d');\n        this.time = 0;\n        this.fractals = [];\n        this.mandelbrots = [];\n        this.juliasets = [];\n        this.sierpinskis = [];\n        \n        this.init();\n        this.createFractals();\n        this.animate();\n    }\n    \n    init() {\n        this.canvas.style.position = 'fixed';\n        this.canvas.style.top = '0';\n        this.canvas.style.left = '0';\n        this.canvas.style.width = '100%';\n        this.canvas.style.height = '100%';\n        this.canvas.style.pointerEvents = 'none';\n        this.canvas.style.zIndex = '300';\n        this.canvas.style.mixBlendMode = 'screen';\n        this.canvas.style.opacity = '0.4';\n        \n        this.resize();\n        document.body.appendChild(this.canvas);\n    }\n    \n    resize() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n    }\n    \n    createFractals() {\n        // Create multiple Mandelbrot instances with different parameters\n        for (let i = 0; i < 3; i++) {\n            this.mandelbrots.push(new MandelbrotFractal(\n                -0.5 + (Math.random() - 0.5) * 0.1,\n                0 + (Math.random() - 0.5) * 0.1,\n                2 + Math.random(),\n                50 + Math.random() * 50\n            ));\n        }\n        \n        // Create Julia sets with evolving parameters\n        for (let i = 0; i < 4; i++) {\n            this.juliasets.push(new JuliaSet(\n                -0.8 + Math.random() * 1.6,\n                -0.8 + Math.random() * 1.6,\n                80 + Math.random() * 40\n            ));\n        }\n        \n        // Create dynamic Sierpinski triangles\n        for (let i = 0; i < 2; i++) {\n            this.sierpinskis.push(new SierpinskiTriangle(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height,\n                100 + Math.random() * 200\n            ));\n        }\n        \n        // Create procedural tree fractals\n        this.createTreeFractals();\n        \n        // Create quantum foam fractals\n        this.createQuantumFoam();\n    }\n    \n    createTreeFractals() {\n        for (let i = 0; i < 5; i++) {\n            const tree = new FractalTree(\n                Math.random() * this.canvas.width,\n                this.canvas.height,\n                Math.random() * Math.PI / 6 + Math.PI / 12,\n                5 + Math.floor(Math.random() * 4),\n                0.6 + Math.random() * 0.3\n            );\n            this.fractals.push(tree);\n        }\n    }\n    \n    createQuantumFoam() {\n        for (let i = 0; i < 10; i++) {\n            const foam = new QuantumFoam(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height,\n                Math.random() * 50 + 20\n            );\n            this.fractals.push(foam);\n        }\n    }\n    \n    update() {\n        this.time += 0.016;\n        \n        // Update all fractals\n        this.fractals.forEach(fractal => fractal.update(this.time));\n        this.mandelbrots.forEach(mandelbrot => mandelbrot.update(this.time));\n        this.juliasets.forEach(julia => julia.update(this.time));\n        this.sierpinskis.forEach(sierpinski => sierpinski.update(this.time));\n    }\n    \n    render() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        // Render based on current state\n        const baseOpacity = 0.1 + Math.sin(this.time * 0.5) * 0.05;\n        \n        // Render Mandelbrot sets\n        this.mandelbrots.forEach((mandelbrot, index) => {\n            this.renderMandelbrot(mandelbrot, baseOpacity, index);\n        });\n        \n        // Render Julia sets\n        this.juliasets.forEach((julia, index) => {\n            this.renderJuliaSet(julia, baseOpacity, index);\n        });\n        \n        // Render Sierpinski triangles\n        this.sierpinskis.forEach(sierpinski => {\n            sierpinski.render(this.ctx, baseOpacity);\n        });\n        \n        // Render other fractals\n        this.fractals.forEach(fractal => {\n            fractal.render(this.ctx, baseOpacity);\n        });\n    }\n    \n    renderMandelbrot(mandelbrot, baseOpacity, index) {\n        const width = this.canvas.width / 4;\n        const height = this.canvas.height / 4;\n        const startX = (index % 2) * width * 2;\n        const startY = Math.floor(index / 2) * height * 2;\n        \n        for (let x = 0; x < width; x += 2) {\n            for (let y = 0; y < height; y += 2) {\n                const iterations = mandelbrot.calculate(\n                    startX + x,\n                    startY + y,\n                    this.canvas.width,\n                    this.canvas.height\n                );\n                \n                if (iterations < mandelbrot.maxIterations) {\n                    const color = this.getIterationColor(iterations, mandelbrot.maxIterations);\n                    this.ctx.fillStyle = color;\n                    this.ctx.globalAlpha = baseOpacity;\n                    this.ctx.fillRect(startX + x, startY + y, 2, 2);\n                }\n            }\n        }\n    }\n    \n    renderJuliaSet(julia, baseOpacity, index) {\n        const size = 150;\n        const centerX = (index % 2) * this.canvas.width / 2 + this.canvas.width / 4;\n        const centerY = Math.floor(index / 2) * this.canvas.height / 2 + this.canvas.height / 4;\n        \n        for (let x = -size; x < size; x += 3) {\n            for (let y = -size; y < size; y += 3) {\n                const iterations = julia.calculate(x, y);\n                \n                if (iterations < julia.maxIterations) {\n                    const color = this.getIterationColor(iterations, julia.maxIterations, 'julia');\n                    this.ctx.fillStyle = color;\n                    this.ctx.globalAlpha = baseOpacity * 0.8;\n                    this.ctx.fillRect(centerX + x, centerY + y, 3, 3);\n                }\n            }\n        }\n    }\n    \n    getIterationColor(iterations, maxIterations, type = 'mandelbrot') {\n        const ratio = iterations / maxIterations;\n        \n        if (type === 'julia') {\n            const hue = (ratio * 360 + this.time * 10) % 360;\n            const saturation = 70 + ratio * 30;\n            const lightness = 30 + ratio * 50;\n            return `hsla(${hue}, ${saturation}%, ${lightness}%, 0.8)`;\n        } else {\n            const r = Math.sin(ratio * Math.PI * 2 + this.time) * 127 + 128;\n            const g = Math.sin(ratio * Math.PI * 2 + this.time + Math.PI / 3) * 127 + 128;\n            const b = Math.sin(ratio * Math.PI * 2 + this.time + Math.PI * 2 / 3) * 127 + 128;\n            return `rgba(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)}, 0.6)`;\n        }\n    }\n    \n    animate() {\n        this.update();\n        this.render();\n        requestAnimationFrame(() => this.animate());\n    }\n}\n\nclass MandelbrotFractal {\n    constructor(centerX = -0.5, centerY = 0, zoom = 2, maxIterations = 100) {\n        this.centerX = centerX;\n        this.centerY = centerY;\n        this.zoom = zoom;\n        this.maxIterations = maxIterations;\n        this.baseZoom = zoom;\n        this.phase = Math.random() * Math.PI * 2;\n    }\n    \n    update(time) {\n        // Slowly zoom and pan through interesting regions\n        this.zoom = this.baseZoom + Math.sin(time * 0.1 + this.phase) * this.baseZoom * 0.3;\n        this.centerX += Math.cos(time * 0.05) * 0.001;\n        this.centerY += Math.sin(time * 0.07) * 0.001;\n    }\n    \n    calculate(pixelX, pixelY, canvasWidth, canvasHeight) {\n        // Convert pixel coordinates to complex plane\n        const zoomFactor = 4 / this.zoom;\n        const real = (pixelX - canvasWidth / 2) * zoomFactor / canvasWidth + this.centerX;\n        const imag = (pixelY - canvasHeight / 2) * zoomFactor / canvasHeight + this.centerY;\n        \n        return this.mandelbrotIterations(real, imag);\n    }\n    \n    mandelbrotIterations(cr, ci) {\n        let zr = 0;\n        let zi = 0;\n        let iterations = 0;\n        \n        while (iterations < this.maxIterations && (zr * zr + zi * zi) < 4) {\n            const temp = zr * zr - zi * zi + cr;\n            zi = 2 * zr * zi + ci;\n            zr = temp;\n            iterations++;\n        }\n        \n        return iterations;\n    }\n}\n\nclass JuliaSet {\n    constructor(cReal = -0.7, cImag = 0.27015, maxIterations = 100) {\n        this.cReal = cReal;\n        this.cImag = cImag;\n        this.maxIterations = maxIterations;\n        this.baseCReal = cReal;\n        this.baseCImag = cImag;\n        this.phase = Math.random() * Math.PI * 2;\n    }\n    \n    update(time) {\n        // Animate the Julia set parameters\n        this.cReal = this.baseCReal + Math.sin(time * 0.3 + this.phase) * 0.2;\n        this.cImag = this.baseCImag + Math.cos(time * 0.4 + this.phase + 1) * 0.2;\n    }\n    \n    calculate(x, y) {\n        const scale = 0.01;\n        let zr = x * scale;\n        let zi = y * scale;\n        let iterations = 0;\n        \n        while (iterations < this.maxIterations && (zr * zr + zi * zi) < 4) {\n            const temp = zr * zr - zi * zi + this.cReal;\n            zi = 2 * zr * zi + this.cImag;\n            zr = temp;\n            iterations++;\n        }\n        \n        return iterations;\n    }\n}\n\nclass SierpinskiTriangle {\n    constructor(x, y, size) {\n        this.x = x;\n        this.y = y;\n        this.size = size;\n        this.baseSize = size;\n        this.rotation = 0;\n        this.rotationSpeed = (Math.random() - 0.5) * 0.02;\n        this.depth = 5;\n        this.phase = Math.random() * Math.PI * 2;\n    }\n    \n    update(time) {\n        this.rotation += this.rotationSpeed;\n        this.size = this.baseSize + Math.sin(time * 0.5 + this.phase) * this.baseSize * 0.3;\n    }\n    \n    render(ctx, baseOpacity) {\n        ctx.save();\n        ctx.translate(this.x, this.y);\n        ctx.rotate(this.rotation);\n        ctx.globalAlpha = baseOpacity;\n        \n        this.drawSierpinski(ctx, 0, 0, this.size, this.depth);\n        \n        ctx.restore();\n    }\n    \n    drawSierpinski(ctx, x, y, size, depth) {\n        if (depth === 0) {\n            ctx.strokeStyle = `hsl(${(Date.now() * 0.1 + this.phase * 100) % 360}, 70%, 60%)`;\n            ctx.lineWidth = 1;\n            \n            ctx.beginPath();\n            ctx.moveTo(x, y - size / 2);\n            ctx.lineTo(x - size / 2, y + size / 2);\n            ctx.lineTo(x + size / 2, y + size / 2);\n            ctx.closePath();\n            ctx.stroke();\n            return;\n        }\n        \n        const newSize = size / 2;\n        const offset = size / 4;\n        \n        // Top triangle\n        this.drawSierpinski(ctx, x, y - offset, newSize, depth - 1);\n        \n        // Bottom left triangle\n        this.drawSierpinski(ctx, x - offset, y + offset, newSize, depth - 1);\n        \n        // Bottom right triangle\n        this.drawSierpinski(ctx, x + offset, y + offset, newSize, depth - 1);\n    }\n}\n\nclass FractalTree {\n    constructor(x, y, angle, depth, branchRatio) {\n        this.x = x;\n        this.y = y;\n        this.baseAngle = angle;\n        this.angle = angle;\n        this.depth = depth;\n        this.branchRatio = branchRatio;\n        this.length = 80;\n        this.phase = Math.random() * Math.PI * 2;\n        this.windSpeed = Math.random() * 0.02 + 0.01;\n    }\n    \n    update(time) {\n        // Simulate wind effect\n        this.angle = this.baseAngle + Math.sin(time * this.windSpeed + this.phase) * 0.3;\n    }\n    \n    render(ctx, baseOpacity) {\n        ctx.save();\n        ctx.globalAlpha = baseOpacity;\n        ctx.strokeStyle = `hsl(${(Date.now() * 0.05 + this.phase * 50) % 360}, 60%, 50%)`;\n        ctx.lineWidth = this.depth;\n        \n        this.drawBranch(ctx, this.x, this.y, this.length, -Math.PI / 2, this.depth);\n        \n        ctx.restore();\n    }\n    \n    drawBranch(ctx, x, y, length, angle, depth) {\n        if (depth === 0 || length < 2) return;\n        \n        const endX = x + Math.cos(angle) * length;\n        const endY = y + Math.sin(angle) * length;\n        \n        ctx.beginPath();\n        ctx.moveTo(x, y);\n        ctx.lineTo(endX, endY);\n        ctx.stroke();\n        \n        const newLength = length * this.branchRatio;\n        const angleOffset = this.angle;\n        \n        // Left branch\n        this.drawBranch(ctx, endX, endY, newLength, angle - angleOffset, depth - 1);\n        \n        // Right branch\n        this.drawBranch(ctx, endX, endY, newLength, angle + angleOffset, depth - 1);\n        \n        // Sometimes add a third branch for more complexity\n        if (Math.random() < 0.3 && depth > 2) {\n            this.drawBranch(ctx, endX, endY, newLength * 0.7, angle, depth - 1);\n        }\n    }\n}\n\nclass QuantumFoam {\n    constructor(x, y, radius) {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.baseRadius = radius;\n        this.bubbles = [];\n        this.phase = Math.random() * Math.PI * 2;\n        \n        this.createBubbles();\n    }\n    \n    createBubbles() {\n        for (let i = 0; i < 20; i++) {\n            this.bubbles.push({\n                x: (Math.random() - 0.5) * this.radius * 2,\n                y: (Math.random() - 0.5) * this.radius * 2,\n                size: Math.random() * 5 + 1,\n                life: Math.random() * 100 + 50,\n                maxLife: 150,\n                vx: (Math.random() - 0.5) * 0.5,\n                vy: (Math.random() - 0.5) * 0.5,\n                phase: Math.random() * Math.PI * 2\n            });\n        }\n    }\n    \n    update(time) {\n        this.radius = this.baseRadius + Math.sin(time * 0.8 + this.phase) * this.baseRadius * 0.2;\n        \n        // Update bubbles\n        this.bubbles.forEach(bubble => {\n            bubble.x += bubble.vx;\n            bubble.y += bubble.vy;\n            bubble.life--;\n            \n            // Quantum fluctuation\n            bubble.x += Math.sin(time * 0.1 + bubble.phase) * 0.2;\n            bubble.y += Math.cos(time * 0.13 + bubble.phase) * 0.2;\n            \n            if (bubble.life <= 0) {\n                // Respawn bubble\n                bubble.x = (Math.random() - 0.5) * this.radius * 2;\n                bubble.y = (Math.random() - 0.5) * this.radius * 2;\n                bubble.life = bubble.maxLife;\n                bubble.vx = (Math.random() - 0.5) * 0.5;\n                bubble.vy = (Math.random() - 0.5) * 0.5;\n            }\n        });\n    }\n    \n    render(ctx, baseOpacity) {\n        ctx.save();\n        \n        // Render quantum field\n        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);\n        gradient.addColorStop(0, `hsla(${(Date.now() * 0.1 + this.phase * 100) % 360}, 80%, 60%, ${baseOpacity * 0.2})`);\n        gradient.addColorStop(0.5, `hsla(${(Date.now() * 0.1 + this.phase * 100 + 120) % 360}, 70%, 50%, ${baseOpacity * 0.1})`);\n        gradient.addColorStop(1, 'transparent');\n        \n        ctx.fillStyle = gradient;\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Render quantum bubbles\n        this.bubbles.forEach(bubble => {\n            const opacity = (bubble.life / bubble.maxLife) * baseOpacity;\n            ctx.globalAlpha = opacity;\n            \n            const bubbleX = this.x + bubble.x;\n            const bubbleY = this.y + bubble.y;\n            \n            ctx.fillStyle = `hsl(${(Date.now() * 0.2 + bubble.phase * 50) % 360}, 80%, 70%)`;\n            ctx.beginPath();\n            ctx.arc(bubbleX, bubbleY, bubble.size, 0, Math.PI * 2);\n            ctx.fill();\n            \n            // Quantum entanglement lines\n            if (Math.random() < 0.1) {\n                const nearbyBubbles = this.bubbles.filter(b => {\n                    const dx = b.x - bubble.x;\n                    const dy = b.y - bubble.y;\n                    return Math.sqrt(dx * dx + dy * dy) < 30 && b !== bubble;\n                });\n                \n                nearbyBubbles.forEach(nearby => {\n                    ctx.strokeStyle = `hsla(${(Date.now() * 0.15 + bubble.phase * 30) % 360}, 60%, 60%, ${opacity * 0.3})`;\n                    ctx.lineWidth = 1;\n                    ctx.beginPath();\n                    ctx.moveTo(bubbleX, bubbleY);\n                    ctx.lineTo(this.x + nearby.x, this.y + nearby.y);\n                    ctx.stroke();\n                });\n            }\n        });\n        \n        ctx.restore();\n    }\n}\n\n// Initialize when DOM loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    new FractalEngine();\n});