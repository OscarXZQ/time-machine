class QuantumEntanglementVisualizer {\n    constructor() {\n        this.canvas = document.createElement('canvas');\n        this.ctx = this.canvas.getContext('2d');\n        this.quantumPairs = [];\n        this.entanglementFields = [];\n        this.waveFunctions = [];\n        this.superpositionClouds = [];\n        this.time = 0;\n        this.observationEvents = [];\n        \n        this.init();\n        this.createQuantumSystems();\n        this.animate();\n    }\n    \n    init() {\n        this.canvas.style.position = 'fixed';\n        this.canvas.style.top = '0';\n        this.canvas.style.left = '0';\n        this.canvas.style.width = '100%';\n        this.canvas.style.height = '100%';\n        this.canvas.style.pointerEvents = 'none';\n        this.canvas.style.zIndex = '450';\n        this.canvas.style.mixBlendMode = 'screen';\n        this.canvas.style.opacity = '0.5';\n        \n        this.resize();\n        document.body.appendChild(this.canvas);\n        \n        this.bindEvents();\n    }\n    \n    resize() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n    }\n    \n    bindEvents() {\n        document.addEventListener('travel-start', () => {\n            this.createQuantumTurbulence();\n            this.activateEntanglement();\n        });\n        \n        document.addEventListener('calibrate-start', () => {\n            this.stabilizeQuantumFields();\n        });\n        \n        document.addEventListener('click', (e) => {\n            this.createObservationEvent(e.clientX, e.clientY);\n        });\n    }\n    \n    createQuantumSystems() {\n        // Create entangled particle pairs\n        this.createEntangledPairs();\n        \n        // Create quantum wave functions\n        this.createWaveFunctions();\n        \n        // Create superposition clouds\n        this.createSuperpositionClouds();\n        \n        // Create entanglement field networks\n        this.createEntanglementFields();\n    }\n    \n    createEntangledPairs() {\n        for (let i = 0; i < 8; i++) {\n            const pair = new QuantumEntangledPair(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height\n            );\n            this.quantumPairs.push(pair);\n        }\n    }\n    \n    createWaveFunctions() {\n        for (let i = 0; i < 12; i++) {\n            this.waveFunctions.push(new QuantumWaveFunction(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height,\n                Math.random() * 0.1 + 0.05\n            ));\n        }\n    }\n    \n    createSuperpositionClouds() {\n        for (let i = 0; i < 6; i++) {\n            this.superpositionClouds.push(new SuperpositionCloud(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height\n            ));\n        }\n    }\n    \n    createEntanglementFields() {\n        // Connect some quantum pairs with entanglement fields\n        for (let i = 0; i < this.quantumPairs.length - 1; i++) {\n            if (Math.random() < 0.3) {\n                this.entanglementFields.push(new EntanglementField(\n                    this.quantumPairs[i],\n                    this.quantumPairs[i + 1]\n                ));\n            }\n        }\n    }\n    \n    createQuantumTurbulence() {\n        // Add quantum turbulence during time travel\n        for (let i = 0; i < 5; i++) {\n            this.quantumPairs.push(new QuantumEntangledPair(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height,\n                true // turbulent mode\n            ));\n        }\n        \n        // Increase wave function activity\n        this.waveFunctions.forEach(wave => wave.amplify(2.0));\n    }\n    \n    activateEntanglement() {\n        this.quantumPairs.forEach(pair => pair.activate());\n        this.entanglementFields.forEach(field => field.strengthen());\n    }\n    \n    stabilizeQuantumFields() {\n        this.waveFunctions.forEach(wave => wave.stabilize());\n        this.superpositionClouds.forEach(cloud => cloud.collapse());\n    }\n    \n    createObservationEvent(x, y) {\n        const event = new QuantumObservation(x, y);\n        this.observationEvents.push(event);\n        \n        // Observation affects nearby quantum systems\n        this.quantumPairs.forEach(pair => {\n            const distance = Math.sqrt(\n                Math.pow(pair.center.x - x, 2) + Math.pow(pair.center.y - y, 2)\n            );\n            \n            if (distance < 150) {\n                pair.observe();\n            }\n        });\n        \n        this.superpositionClouds.forEach(cloud => {\n            const distance = Math.sqrt(\n                Math.pow(cloud.x - x, 2) + Math.pow(cloud.y - y, 2)\n            );\n            \n            if (distance < 100) {\n                cloud.forceCollapse();\n            }\n        });\n    }\n    \n    update() {\n        this.time += 0.016;\n        \n        // Update quantum systems\n        this.quantumPairs = this.quantumPairs.filter(pair => {\n            pair.update(this.time);\n            return !pair.finished;\n        });\n        \n        this.waveFunctions.forEach(wave => wave.update(this.time));\n        \n        this.superpositionClouds = this.superpositionClouds.filter(cloud => {\n            cloud.update(this.time);\n            return !cloud.finished;\n        });\n        \n        this.entanglementFields = this.entanglementFields.filter(field => {\n            field.update(this.time);\n            return !field.finished;\n        });\n        \n        this.observationEvents = this.observationEvents.filter(event => {\n            event.update();\n            return !event.finished;\n        });\n        \n        // Spontaneous quantum events\n        if (Math.random() < 0.01) {\n            this.createSpontaneousEntanglement();\n        }\n    }\n    \n    createSpontaneousEntanglement() {\n        if (this.quantumPairs.length < 2) return;\n        \n        const pair1 = this.quantumPairs[Math.floor(Math.random() * this.quantumPairs.length)];\n        const pair2 = this.quantumPairs[Math.floor(Math.random() * this.quantumPairs.length)];\n        \n        if (pair1 !== pair2) {\n            this.entanglementFields.push(new EntanglementField(pair1, pair2));\n        }\n    }\n    \n    render() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        // Render wave functions first (background)\n        this.waveFunctions.forEach(wave => wave.render(this.ctx));\n        \n        // Render superposition clouds\n        this.superpositionClouds.forEach(cloud => cloud.render(this.ctx));\n        \n        // Render entanglement fields\n        this.entanglementFields.forEach(field => field.render(this.ctx));\n        \n        // Render quantum pairs\n        this.quantumPairs.forEach(pair => pair.render(this.ctx));\n        \n        // Render observation events\n        this.observationEvents.forEach(event => event.render(this.ctx));\n        \n        // Render quantum field statistics\n        this.renderQuantumStats();\n    }\n    \n    renderQuantumStats() {\n        this.ctx.save();\n        this.ctx.font = '11px monospace';\n        this.ctx.fillStyle = 'rgba(255, 0, 255, 0.7)';\n        \n        const entangled = this.quantumPairs.filter(p => p.isEntangled).length;\n        const coherent = this.waveFunctions.filter(w => w.coherence > 0.5).length;\n        const superposed = this.superpositionClouds.filter(c => !c.collapsed).length;\n        \n        this.ctx.fillText(`Entangled Pairs: ${entangled}`, this.canvas.width - 200, 30);\n        this.ctx.fillText(`Coherent Waves: ${coherent}`, this.canvas.width - 200, 50);\n        this.ctx.fillText(`Superposed States: ${superposed}`, this.canvas.width - 200, 70);\n        \n        this.ctx.restore();\n    }\n    \n    animate() {\n        this.update();\n        this.render();\n        requestAnimationFrame(() => this.animate());\n    }\n}\n\nclass QuantumEntangledPair {\n    constructor(x, y, turbulent = false) {\n        this.center = { x, y };\n        this.particle1 = new QuantumParticle(x - 50, y, 'up');\n        this.particle2 = new QuantumParticle(x + 50, y, 'down');\n        this.isEntangled = true;\n        this.entanglementStrength = 1.0;\n        this.distance = 100;\n        this.oscillationPhase = Math.random() * Math.PI * 2;\n        this.finished = false;\n        this.life = turbulent ? 200 : 1000;\n        this.maxLife = this.life;\n        this.turbulent = turbulent;\n        this.observationCount = 0;\n    }\n    \n    activate() {\n        this.particle1.activate();\n        this.particle2.activate();\n    }\n    \n    observe() {\n        this.observationCount++;\n        \n        // Quantum measurement causes state collapse\n        this.particle1.collapse();\n        this.particle2.collapse();\n        \n        // Entanglement weakens with observation\n        this.entanglementStrength *= 0.8;\n        \n        if (this.entanglementStrength < 0.1) {\n            this.isEntangled = false;\n        }\n    }\n    \n    update(time) {\n        // Orbital motion\n        this.oscillationPhase += 0.02 + (this.turbulent ? 0.05 : 0);\n        \n        const radius = this.distance / 2;\n        this.particle1.x = this.center.x + Math.cos(this.oscillationPhase) * radius;\n        this.particle1.y = this.center.y + Math.sin(this.oscillationPhase) * radius;\n        \n        this.particle2.x = this.center.x - Math.cos(this.oscillationPhase) * radius;\n        this.particle2.y = this.center.y - Math.sin(this.oscillationPhase) * radius;\n        \n        // Entangled state correlation\n        if (this.isEntangled) {\n            if (this.particle1.spin === 'up') {\n                this.particle2.spin = 'down';\n            } else {\n                this.particle2.spin = 'up';\n            }\n        }\n        \n        this.particle1.update(time);\n        this.particle2.update(time);\n        \n        // Quantum tunneling in turbulent mode\n        if (this.turbulent && Math.random() < 0.05) {\n            const temp = { x: this.particle1.x, y: this.particle1.y };\n            this.particle1.x = this.particle2.x;\n            this.particle1.y = this.particle2.y;\n            this.particle2.x = temp.x;\n            this.particle2.y = temp.y;\n        }\n        \n        this.life--;\n        if (this.life <= 0) {\n            this.finished = true;\n        }\n    }\n    \n    render(ctx) {\n        const alpha = this.life / this.maxLife;\n        \n        // Render entanglement connection\n        if (this.isEntangled) {\n            ctx.save();\n            ctx.strokeStyle = `rgba(255, 0, 255, ${this.entanglementStrength * alpha * 0.6})`;\n            ctx.lineWidth = 2 + this.entanglementStrength * 2;\n            ctx.shadowBlur = 10;\n            ctx.shadowColor = '#ff00ff';\n            \n            // Quantum correlation visualization\n            const gradient = ctx.createLinearGradient(\n                this.particle1.x, this.particle1.y,\n                this.particle2.x, this.particle2.y\n            );\n            gradient.addColorStop(0, `rgba(255, 0, 255, ${this.entanglementStrength * alpha})`);\n            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');\n            gradient.addColorStop(1, `rgba(255, 0, 255, ${this.entanglementStrength * alpha})`);\n            \n            ctx.strokeStyle = gradient;\n            ctx.beginPath();\n            ctx.moveTo(this.particle1.x, this.particle1.y);\n            ctx.lineTo(this.particle2.x, this.particle2.y);\n            ctx.stroke();\n            \n            // Interference pattern along connection\n            for (let i = 0.1; i < 1; i += 0.1) {\n                const x = this.particle1.x + (this.particle2.x - this.particle1.x) * i;\n                const y = this.particle1.y + (this.particle2.y - this.particle1.y) * i;\n                const intensity = Math.sin(this.oscillationPhase * 4 + i * Math.PI * 8) * 0.5 + 0.5;\n                \n                ctx.fillStyle = `rgba(255, 0, 255, ${intensity * this.entanglementStrength * alpha})`;\n                ctx.beginPath();\n                ctx.arc(x, y, 2, 0, Math.PI * 2);\n                ctx.fill();\n            }\n            \n            ctx.restore();\n        }\n        \n        // Render particles\n        this.particle1.render(ctx, alpha);\n        this.particle2.render(ctx, alpha);\n        \n        // Render observation indicator\n        if (this.observationCount > 0) {\n            ctx.save();\n            ctx.font = '10px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;\n            ctx.textAlign = 'center';\n            ctx.fillText(\n                `Observed: ${this.observationCount}`,\n                this.center.x,\n                this.center.y + 30\n            );\n            ctx.restore();\n        }\n    }\n}\n\nclass QuantumParticle {\n    constructor(x, y, spin) {\n        this.x = x;\n        this.y = y;\n        this.spin = spin;\n        this.size = 3 + Math.random() * 2;\n        this.phase = Math.random() * Math.PI * 2;\n        this.amplitude = 1.0;\n        this.isActive = false;\n        this.collapsed = false;\n        this.waveFunction = [];\n        \n        this.generateWaveFunction();\n    }\n    \n    generateWaveFunction() {\n        for (let i = 0; i < 20; i++) {\n            const angle = (i / 20) * Math.PI * 2;\n            this.waveFunction.push({\n                angle: angle,\n                radius: 15 + Math.random() * 10,\n                amplitude: Math.random() * 0.8 + 0.2\n            });\n        }\n    }\n    \n    activate() {\n        this.isActive = true;\n    }\n    \n    collapse() {\n        this.collapsed = true;\n        this.amplitude *= 0.3;\n    }\n    \n    update(time) {\n        this.phase += 0.1;\n        \n        // Update wave function\n        this.waveFunction.forEach(component => {\n            component.angle += 0.02;\n            component.amplitude *= 0.995; // Natural decoherence\n        });\n        \n        // Spontaneous emission\n        if (Math.random() < 0.001) {\n            this.size *= 1.2;\n            setTimeout(() => this.size /= 1.2, 100);\n        }\n    }\n    \n    render(ctx, parentAlpha = 1) {\n        ctx.save();\n        \n        const spinColor = this.spin === 'up' ? '#00ffff' : '#ff6600';\n        \n        // Render wave function if not collapsed\n        if (!this.collapsed) {\n            ctx.strokeStyle = spinColor.replace(')', ', 0.3)') + ')';\n            ctx.lineWidth = 1;\n            \n            ctx.beginPath();\n            this.waveFunction.forEach((component, index) => {\n                const radius = component.radius * component.amplitude;\n                const x = this.x + Math.cos(component.angle) * radius;\n                const y = this.y + Math.sin(component.angle) * radius;\n                \n                if (index === 0) {\n                    ctx.moveTo(x, y);\n                } else {\n                    ctx.lineTo(x, y);\n                }\n            });\n            ctx.closePath();\n            ctx.stroke();\n        }\n        \n        // Render particle core\n        const intensity = this.amplitude * parentAlpha;\n        const pulseSize = this.size + Math.sin(this.phase) * 2;\n        \n        ctx.shadowBlur = 10 + (this.isActive ? 5 : 0);\n        ctx.shadowColor = spinColor;\n        \n        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, pulseSize);\n        gradient.addColorStop(0, spinColor.replace(')', `, ${intensity})`);\n        gradient.addColorStop(0.7, spinColor.replace(')', `, ${intensity * 0.5})`);\n        gradient.addColorStop(1, 'transparent');\n        \n        ctx.fillStyle = gradient;\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, pulseSize, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Spin indicator\n        const arrowY = this.y + (this.spin === 'up' ? -15 : 15);\n        ctx.strokeStyle = spinColor;\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.moveTo(this.x, this.y);\n        ctx.lineTo(this.x, arrowY);\n        ctx.stroke();\n        \n        // Arrow head\n        const arrowSize = 4;\n        ctx.beginPath();\n        if (this.spin === 'up') {\n            ctx.moveTo(this.x - arrowSize, arrowY + arrowSize);\n            ctx.lineTo(this.x, arrowY);\n            ctx.lineTo(this.x + arrowSize, arrowY + arrowSize);\n        } else {\n            ctx.moveTo(this.x - arrowSize, arrowY - arrowSize);\n            ctx.lineTo(this.x, arrowY);\n            ctx.lineTo(this.x + arrowSize, arrowY - arrowSize);\n        }\n        ctx.stroke();\n        \n        ctx.restore();\n    }\n}\n\nclass QuantumWaveFunction {\n    constructor(x, y, frequency) {\n        this.x = x;\n        this.y = y;\n        this.frequency = frequency;\n        this.amplitude = 1.0;\n        this.baseAmplitude = 1.0;\n        this.wavelength = 50 + Math.random() * 100;\n        this.phase = 0;\n        this.coherence = 1.0;\n        this.wavePoints = [];\n        \n        this.generateWavePoints();\n    }\n    \n    generateWavePoints() {\n        for (let i = 0; i < 100; i++) {\n            const t = (i / 100) * Math.PI * 4;\n            this.wavePoints.push({\n                t: t,\n                x: this.x + (i - 50) * 4,\n                y: this.y,\n                originalY: this.y\n            });\n        }\n    }\n    \n    amplify(factor) {\n        this.amplitude = this.baseAmplitude * factor;\n    }\n    \n    stabilize() {\n        this.amplitude = this.baseAmplitude;\n        this.coherence = Math.min(1.0, this.coherence + 0.1);\n    }\n    \n    update(time) {\n        this.phase = time * this.frequency;\n        \n        // Natural decoherence\n        this.coherence *= 0.999;\n        \n        // Update wave points\n        this.wavePoints.forEach(point => {\n            const waveValue = Math.sin(point.t + this.phase) * this.amplitude * this.coherence;\n            point.y = point.originalY + waveValue * 30;\n        });\n    }\n    \n    render(ctx) {\n        if (this.coherence < 0.1) return;\n        \n        ctx.save();\n        ctx.strokeStyle = `rgba(100, 255, 255, ${this.coherence * 0.6})`;\n        ctx.lineWidth = 2;\n        ctx.shadowBlur = 5;\n        ctx.shadowColor = '#64ffff';\n        \n        // Render wave\n        ctx.beginPath();\n        this.wavePoints.forEach((point, index) => {\n            if (index === 0) {\n                ctx.moveTo(point.x, point.y);\n            } else {\n                ctx.lineTo(point.x, point.y);\n            }\n        });\n        ctx.stroke();\n        \n        // Render probability density\n        this.wavePoints.forEach((point, index) => {\n            if (index % 5 === 0) {\n                const probability = Math.abs(point.y - point.originalY) / 30;\n                ctx.fillStyle = `rgba(100, 255, 255, ${probability * this.coherence * 0.3})`;\n                ctx.beginPath();\n                ctx.arc(point.x, point.y, 2, 0, Math.PI * 2);\n                ctx.fill();\n            }\n        });\n        \n        ctx.restore();\n    }\n}\n\nclass SuperpositionCloud {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.size = 50 + Math.random() * 50;\n        this.particles = [];\n        this.collapsed = false;\n        this.collapseProgress = 0;\n        this.finished = false;\n        this.life = 800;\n        this.maxLife = 800;\n        \n        this.generateParticles();\n    }\n    \n    generateParticles() {\n        for (let i = 0; i < 30; i++) {\n            this.particles.push({\n                x: (Math.random() - 0.5) * this.size * 2,\n                y: (Math.random() - 0.5) * this.size * 2,\n                vx: (Math.random() - 0.5) * 0.5,\n                vy: (Math.random() - 0.5) * 0.5,\n                probability: Math.random(),\n                phase: Math.random() * Math.PI * 2\n            });\n        }\n    }\n    \n    collapse() {\n        if (!this.collapsed) {\n            this.collapsed = true;\n        }\n    }\n    \n    forceCollapse() {\n        this.collapse();\n        this.collapseProgress = 0.5; // Accelerated collapse\n    }\n    \n    update(time) {\n        if (this.collapsed) {\n            this.collapseProgress += 0.02;\n            \n            // Particles converge to a single point during collapse\n            this.particles.forEach(particle => {\n                particle.x *= (1 - this.collapseProgress * 0.1);\n                particle.y *= (1 - this.collapseProgress * 0.1);\n            });\n            \n            if (this.collapseProgress >= 1) {\n                this.finished = true;\n            }\n        } else {\n            // Normal superposition behavior\n            this.particles.forEach(particle => {\n                particle.x += particle.vx;\n                particle.y += particle.vy;\n                particle.phase += 0.1;\n                \n                // Keep particles within cloud bounds\n                if (Math.abs(particle.x) > this.size) particle.vx *= -0.8;\n                if (Math.abs(particle.y) > this.size) particle.vy *= -0.8;\n                \n                // Quantum fluctuation\n                particle.probability += (Math.random() - 0.5) * 0.1;\n                particle.probability = Math.max(0, Math.min(1, particle.probability));\n            });\n        }\n        \n        this.life--;\n        if (this.life <= 0) {\n            this.finished = true;\n        }\n    }\n    \n    render(ctx) {\n        const alpha = this.life / this.maxLife;\n        \n        ctx.save();\n        \n        // Render cloud boundary\n        if (!this.collapsed) {\n            ctx.strokeStyle = `rgba(255, 255, 0, ${alpha * 0.4})`;\n            ctx.lineWidth = 1;\n            ctx.setLineDash([5, 5]);\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n            ctx.stroke();\n            ctx.setLineDash([]);\n        }\n        \n        // Render superposed particles\n        this.particles.forEach(particle => {\n            const intensity = particle.probability * alpha * (this.collapsed ? this.collapseProgress : 1);\n            const particleX = this.x + particle.x;\n            const particleY = this.y + particle.y;\n            \n            // Probability cloud visualization\n            const cloudSize = 8 + Math.sin(particle.phase) * 3;\n            const gradient = ctx.createRadialGradient(\n                particleX, particleY, 0,\n                particleX, particleY, cloudSize\n            );\n            gradient.addColorStop(0, `rgba(255, 255, 0, ${intensity})`);\n            gradient.addColorStop(1, 'transparent');\n            \n            ctx.fillStyle = gradient;\n            ctx.beginPath();\n            ctx.arc(particleX, particleY, cloudSize, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        // Render collapse indicator\n        if (this.collapsed) {\n            ctx.font = '12px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;\n            ctx.textAlign = 'center';\n            ctx.fillText('COLLAPSED', this.x, this.y - this.size - 10);\n        }\n        \n        ctx.restore();\n    }\n}\n\nclass EntanglementField {\n    constructor(pair1, pair2) {\n        this.pair1 = pair1;\n        this.pair2 = pair2;\n        this.strength = 0.5 + Math.random() * 0.5;\n        this.oscillation = 0;\n        this.fieldLines = [];\n        this.finished = false;\n        \n        this.generateFieldLines();\n    }\n    \n    generateFieldLines() {\n        for (let i = 0; i < 8; i++) {\n            const t = i / 8;\n            this.fieldLines.push({\n                t: t,\n                offset: (Math.random() - 0.5) * 50,\n                phase: Math.random() * Math.PI * 2\n            });\n        }\n    }\n    \n    strengthen() {\n        this.strength = Math.min(1.0, this.strength + 0.2);\n    }\n    \n    update(time) {\n        this.oscillation = time * 0.1;\n        \n        // Update field lines\n        this.fieldLines.forEach(line => {\n            line.phase += 0.05;\n        });\n        \n        // Field weakens over time without reinforcement\n        this.strength *= 0.998;\n        \n        if (this.strength < 0.1 || this.pair1.finished || this.pair2.finished) {\n            this.finished = true;\n        }\n    }\n    \n    render(ctx) {\n        if (this.finished) return;\n        \n        ctx.save();\n        ctx.strokeStyle = `rgba(128, 0, 255, ${this.strength * 0.4})`;\n        ctx.lineWidth = 2;\n        ctx.shadowBlur = 8;\n        ctx.shadowColor = '#8000ff';\n        \n        // Render field lines between entangled pairs\n        this.fieldLines.forEach(line => {\n            const startX = this.pair1.center.x;\n            const startY = this.pair1.center.y;\n            const endX = this.pair2.center.x;\n            const endY = this.pair2.center.y;\n            \n            // Create curved field line\n            const midX = (startX + endX) / 2 + line.offset * Math.sin(line.phase);\n            const midY = (startY + endY) / 2 + line.offset * Math.cos(line.phase);\n            \n            ctx.beginPath();\n            ctx.moveTo(startX, startY);\n            ctx.quadraticCurveTo(midX, midY, endX, endY);\n            ctx.stroke();\n            \n            // Field strength indicators\n            const fieldStrengthX = midX + Math.sin(this.oscillation + line.phase) * 20;\n            const fieldStrengthY = midY + Math.cos(this.oscillation + line.phase) * 20;\n            \n            ctx.fillStyle = `rgba(128, 0, 255, ${this.strength})`;\n            ctx.beginPath();\n            ctx.arc(fieldStrengthX, fieldStrengthY, 2, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        ctx.restore();\n    }\n}\n\nclass QuantumObservation {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.radius = 0;\n        this.maxRadius = 100;\n        this.finished = false;\n        this.ripples = [];\n        \n        this.createRipples();\n    }\n    \n    createRipples() {\n        for (let i = 0; i < 5; i++) {\n            this.ripples.push({\n                radius: 0,\n                maxRadius: this.maxRadius + i * 20,\n                speed: 2 + i * 0.5,\n                delay: i * 10,\n                alpha: 1 - i * 0.15\n            });\n        }\n    }\n    \n    update() {\n        let allFinished = true;\n        \n        this.ripples.forEach(ripple => {\n            if (ripple.delay > 0) {\n                ripple.delay--;\n                allFinished = false;\n            } else {\n                ripple.radius += ripple.speed;\n                if (ripple.radius < ripple.maxRadius) {\n                    allFinished = false;\n                }\n            }\n        });\n        \n        this.finished = allFinished;\n    }\n    \n    render(ctx) {\n        ctx.save();\n        \n        this.ripples.forEach(ripple => {\n            if (ripple.radius > 0 && ripple.radius <= ripple.maxRadius) {\n                const progress = ripple.radius / ripple.maxRadius;\n                const alpha = (1 - progress) * ripple.alpha;\n                \n                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;\n                ctx.lineWidth = 2;\n                ctx.shadowBlur = 5;\n                ctx.shadowColor = '#ffffff';\n                \n                ctx.beginPath();\n                ctx.arc(this.x, this.y, ripple.radius, 0, Math.PI * 2);\n                ctx.stroke();\n            }\n        });\n        \n        // Observer effect indicator\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.font = '12px monospace';\n        ctx.textAlign = 'center';\n        ctx.fillText('OBSERVED', this.x, this.y + 5);\n        \n        ctx.restore();\n    }\n}\n\n// Initialize when DOM loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    new QuantumEntanglementVisualizer();\n});