class HapticFeedback {\n    constructor() {\n        this.isSupported = 'vibrate' in navigator;\n        this.gamepadSupported = 'getGamepads' in navigator;\n        this.patterns = {};\n        this.activeVibrations = new Set();\n        this.visualFeedback = [];\n        \n        this.init();\n        this.createPatterns();\n        this.setupVisualFeedback();\n        this.animate();\n    }\n    \n    init() {\n        this.bindEvents();\n        \n        if (this.gamepadSupported) {\n            this.monitorGamepads();\n        }\n    }\n    \n    createPatterns() {\n        this.patterns = {\n            // Basic feedback patterns\n            click: [30],\n            error: [100, 50, 100],\n            success: [50, 30, 50, 30, 200],\n            notification: [200],\n            \n            // Time machine specific patterns\n            calibration: [100, 50, 100, 50, 100, 50, 300],\n            timeTravel: [200, 100, 300, 100, 400, 100, 500],\n            temporalDistortion: [50, 25, 75, 25, 100, 25, 150, 25, 200],\n            quantumFlux: [25, 25, 25, 25, 25, 25, 25, 25, 25, 25],\n            dimensionalShift: [300, 200, 400, 200, 500],\n            arrival: [150, 100, 150, 100, 300],\n            \n            // Ambient patterns for background feel\n            temporalHum: [10, 200, 10, 200, 10, 200],\n            quantumResonance: [5, 50, 5, 50, 5, 50, 5, 50],\n            energyPulse: [75, 150, 75, 150, 75, 150]\n        };\n    }\n    \n    setupVisualFeedback() {\n        // Create visual haptic feedback elements\n        this.hapticContainer = document.createElement('div');\n        this.hapticContainer.style.cssText = `\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            pointer-events: none;\n            z-index: 20000;\n        `;\n        \n        document.body.appendChild(this.hapticContainer);\n    }\n    \n    bindEvents() {\n        // Mouse events\n        document.addEventListener('click', (e) => {\n            this.trigger('click');\n            this.createVisualRipple(e.clientX, e.clientY, 'click');\n        });\n        \n        document.addEventListener('mousedown', (e) => {\n            this.createTactilePressure(e.clientX, e.clientY);\n        });\n        \n        // UI interaction events\n        document.querySelectorAll('button, .preset-btn, .control-btn').forEach(btn => {\n            btn.addEventListener('mouseenter', () => {\n                this.trigger('notification', 0.3);\n                this.createHoverGlow(btn);\n            });\n            \n            btn.addEventListener('click', () => {\n                this.trigger('click');\n                this.createButtonFeedback(btn);\n            });\n        });\n        \n        // Time machine specific events\n        document.addEventListener('travel-start', () => {\n            this.trigger('timeTravel');\n            this.startAmbientFeedback('temporalDistortion');\n            this.createGlobalPulse();\n        });\n        \n        document.addEventListener('calibrate-start', () => {\n            this.trigger('calibration');\n            this.createPrecisionFeedback();\n        });\n        \n        document.addEventListener('arrival-complete', () => {\n            this.trigger('arrival');\n            this.stopAmbientFeedback();\n            this.createArrivalBurst();\n        });\n        \n        // Flux capacitor interactions\n        const fluxCapacitor = document.querySelector('.flux-capacitor');\n        if (fluxCapacitor) {\n            fluxCapacitor.addEventListener('mouseenter', () => {\n                this.startAmbientFeedback('quantumResonance');\n                this.createQuantumField(fluxCapacitor);\n            });\n            \n            fluxCapacitor.addEventListener('mouseleave', () => {\n                this.stopAmbientFeedback();\n            });\n        }\n        \n        // Error states\n        document.addEventListener('error', () => {\n            this.trigger('error');\n            this.createErrorShake();\n        });\n    }\n    \n    trigger(pattern, intensity = 1.0) {\n        if (!this.isSupported || !this.patterns[pattern]) return;\n        \n        const vibrationPattern = this.patterns[pattern].map(duration => \n            Math.floor(duration * intensity)\n        );\n        \n        navigator.vibrate(vibrationPattern);\n        this.activeVibrations.add(pattern);\n        \n        // Remove from active set after pattern completes\n        const totalDuration = vibrationPattern.reduce((sum, duration) => sum + duration, 0);\n        setTimeout(() => {\n            this.activeVibrations.delete(pattern);\n        }, totalDuration);\n        \n        // Trigger gamepad vibration if available\n        this.triggerGamepadVibration(pattern, intensity);\n    }\n    \n    triggerGamepadVibration(pattern, intensity) {\n        if (!this.gamepadSupported) return;\n        \n        const gamepads = navigator.getGamepads();\n        for (let gamepad of gamepads) {\n            if (gamepad && gamepad.vibrationActuator) {\n                const duration = this.getPatternDuration(pattern);\n                gamepad.vibrationActuator.playEffect('dual-rumble', {\n                    startDelay: 0,\n                    duration: duration,\n                    weakMagnitude: intensity * 0.3,\n                    strongMagnitude: intensity * 0.7\n                });\n            }\n        }\n    }\n    \n    getPatternDuration(pattern) {\n        if (!this.patterns[pattern]) return 100;\n        return this.patterns[pattern].reduce((sum, duration) => sum + duration, 0);\n    }\n    \n    startAmbientFeedback(pattern) {\n        if (this.ambientInterval) {\n            clearInterval(this.ambientInterval);\n        }\n        \n        this.ambientInterval = setInterval(() => {\n            this.trigger(pattern, 0.2);\n        }, this.getPatternDuration(pattern) + 500);\n    }\n    \n    stopAmbientFeedback() {\n        if (this.ambientInterval) {\n            clearInterval(this.ambientInterval);\n            this.ambientInterval = null;\n        }\n        navigator.vibrate(0); // Stop any ongoing vibration\n    }\n    \n    createVisualRipple(x, y, type) {\n        const ripple = document.createElement('div');\n        ripple.className = 'haptic-ripple';\n        \n        let color, size;\n        switch (type) {\n            case 'click':\n                color = 'rgba(0, 255, 255, 0.6)';\n                size = 100;\n                break;\n            case 'error':\n                color = 'rgba(255, 0, 0, 0.8)';\n                size = 150;\n                break;\n            case 'success':\n                color = 'rgba(0, 255, 0, 0.6)';\n                size = 120;\n                break;\n            default:\n                color = 'rgba(255, 255, 255, 0.5)';\n                size = 80;\n        }\n        \n        ripple.style.cssText = `\n            position: absolute;\n            left: ${x - size/2}px;\n            top: ${y - size/2}px;\n            width: ${size}px;\n            height: ${size}px;\n            border-radius: 50%;\n            background: radial-gradient(circle, ${color} 0%, transparent 70%);\n            animation: hapticRipple 0.6s ease-out forwards;\n            pointer-events: none;\n        `;\n        \n        this.createRippleAnimation(ripple);\n        this.hapticContainer.appendChild(ripple);\n        \n        setTimeout(() => ripple.remove(), 600);\n    }\n    \n    createRippleAnimation(ripple) {\n        const style = document.createElement('style');\n        style.textContent = `\n            @keyframes hapticRipple {\n                0% {\n                    transform: scale(0);\n                    opacity: 1;\n                }\n                50% {\n                    transform: scale(0.8);\n                    opacity: 0.7;\n                }\n                100% {\n                    transform: scale(1.5);\n                    opacity: 0;\n                }\n            }\n        `;\n        \n        if (!document.getElementById('haptic-ripple-style')) {\n            style.id = 'haptic-ripple-style';\n            document.head.appendChild(style);\n        }\n    }\n    \n    createTactilePressure(x, y) {\n        const pressure = document.createElement('div');\n        pressure.style.cssText = `\n            position: absolute;\n            left: ${x - 25}px;\n            top: ${y - 25}px;\n            width: 50px;\n            height: 50px;\n            border-radius: 50%;\n            background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, transparent 70%);\n            animation: tactilePressure 0.3s ease-out forwards;\n            pointer-events: none;\n        `;\n        \n        const style = document.createElement('style');\n        style.textContent = `\n            @keyframes tactilePressure {\n                0% {\n                    transform: scale(1);\n                    opacity: 0.8;\n                }\n                100% {\n                    transform: scale(0.5);\n                    opacity: 0;\n                }\n            }\n        `;\n        \n        if (!document.getElementById('tactile-pressure-style')) {\n            style.id = 'tactile-pressure-style';\n            document.head.appendChild(style);\n        }\n        \n        this.hapticContainer.appendChild(pressure);\n        setTimeout(() => pressure.remove(), 300);\n    }\n    \n    createHoverGlow(element) {\n        if (element.querySelector('.hover-glow')) return;\n        \n        const glow = document.createElement('div');\n        glow.className = 'hover-glow';\n        glow.style.cssText = `\n            position: absolute;\n            top: -5px;\n            left: -5px;\n            right: -5px;\n            bottom: -5px;\n            background: rgba(0, 255, 255, 0.2);\n            border-radius: inherit;\n            animation: hoverGlow 0.3s ease-out forwards;\n            pointer-events: none;\n            z-index: -1;\n        `;\n        \n        const style = document.createElement('style');\n        style.textContent = `\n            @keyframes hoverGlow {\n                0% { opacity: 0; transform: scale(0.9); }\n                100% { opacity: 1; transform: scale(1); }\n            }\n        `;\n        \n        if (!document.getElementById('hover-glow-style')) {\n            style.id = 'hover-glow-style';\n            document.head.appendChild(style);\n        }\n        \n        element.style.position = 'relative';\n        element.appendChild(glow);\n        \n        setTimeout(() => glow.remove(), 1000);\n    }\n    \n    createButtonFeedback(button) {\n        const feedback = document.createElement('div');\n        const rect = button.getBoundingClientRect();\n        \n        feedback.style.cssText = `\n            position: absolute;\n            left: ${rect.left}px;\n            top: ${rect.top}px;\n            width: ${rect.width}px;\n            height: ${rect.height}px;\n            border: 2px solid rgba(255, 255, 255, 0.8);\n            border-radius: inherit;\n            animation: buttonFeedback 0.2s ease-out forwards;\n            pointer-events: none;\n        `;\n        \n        const style = document.createElement('style');\n        style.textContent = `\n            @keyframes buttonFeedback {\n                0% {\n                    transform: scale(1);\n                    opacity: 1;\n                }\n                100% {\n                    transform: scale(1.1);\n                    opacity: 0;\n                }\n            }\n        `;\n        \n        if (!document.getElementById('button-feedback-style')) {\n            style.id = 'button-feedback-style';\n            document.head.appendChild(style);\n        }\n        \n        this.hapticContainer.appendChild(feedback);\n        setTimeout(() => feedback.remove(), 200);\n    }\n    \n    createGlobalPulse() {\n        const pulse = document.createElement('div');\n        pulse.style.cssText = `\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: radial-gradient(circle at center, rgba(0, 255, 255, 0.1) 0%, transparent 70%);\n            animation: globalPulse 2s ease-in-out infinite;\n            pointer-events: none;\n        `;\n        \n        const style = document.createElement('style');\n        style.textContent = `\n            @keyframes globalPulse {\n                0%, 100% {\n                    transform: scale(1);\n                    opacity: 0.3;\n                }\n                50% {\n                    transform: scale(1.05);\n                    opacity: 0.7;\n                }\n            }\n        `;\n        \n        if (!document.getElementById('global-pulse-style')) {\n            style.id = 'global-pulse-style';\n            document.head.appendChild(style);\n        }\n        \n        this.hapticContainer.appendChild(pulse);\n        this.globalPulse = pulse;\n    }\n    \n    createPrecisionFeedback() {\n        const crosshairs = document.createElement('div');\n        crosshairs.style.cssText = `\n            position: fixed;\n            top: 50%;\n            left: 50%;\n            width: 100px;\n            height: 100px;\n            transform: translate(-50%, -50%);\n            border: 2px solid rgba(255, 215, 0, 0.8);\n            border-radius: 50%;\n            animation: precisionTarget 1s ease-out forwards;\n            pointer-events: none;\n        `;\n        \n        const style = document.createElement('style');\n        style.textContent = `\n            @keyframes precisionTarget {\n                0% {\n                    transform: translate(-50%, -50%) scale(2);\n                    opacity: 0;\n                }\n                50% {\n                    transform: translate(-50%, -50%) scale(1);\n                    opacity: 1;\n                }\n                100% {\n                    transform: translate(-50%, -50%) scale(0.8);\n                    opacity: 0;\n                }\n            }\n        `;\n        \n        if (!document.getElementById('precision-target-style')) {\n            style.id = 'precision-target-style';\n            document.head.appendChild(style);\n        }\n        \n        this.hapticContainer.appendChild(crosshairs);\n        setTimeout(() => crosshairs.remove(), 1000);\n    }\n    \n    createArrivalBurst() {\n        if (this.globalPulse) {\n            this.globalPulse.remove();\n            this.globalPulse = null;\n        }\n        \n        for (let i = 0; i < 12; i++) {\n            setTimeout(() => {\n                const burst = document.createElement('div');\n                const angle = (i / 12) * Math.PI * 2;\n                const distance = 300;\n                const x = window.innerWidth / 2 + Math.cos(angle) * distance;\n                const y = window.innerHeight / 2 + Math.sin(angle) * distance;\n                \n                burst.style.cssText = `\n                    position: absolute;\n                    left: ${x}px;\n                    top: ${y}px;\n                    width: 20px;\n                    height: 20px;\n                    background: radial-gradient(circle, rgba(255, 215, 0, 0.8) 0%, transparent 70%);\n                    border-radius: 50%;\n                    animation: arrivalBurst 1s ease-out forwards;\n                    pointer-events: none;\n                `;\n                \n                const style = document.createElement('style');\n                style.textContent = `\n                    @keyframes arrivalBurst {\n                        0% {\n                            transform: scale(0);\n                            opacity: 1;\n                        }\n                        50% {\n                            transform: scale(3);\n                            opacity: 0.8;\n                        }\n                        100% {\n                            transform: scale(5);\n                            opacity: 0;\n                        }\n                    }\n                `;\n                \n                if (!document.getElementById('arrival-burst-style')) {\n                    style.id = 'arrival-burst-style';\n                    document.head.appendChild(style);\n                }\n                \n                this.hapticContainer.appendChild(burst);\n                setTimeout(() => burst.remove(), 1000);\n            }, i * 100);\n        }\n    }\n    \n    createQuantumField(element) {\n        const rect = element.getBoundingClientRect();\n        const field = document.createElement('div');\n        \n        field.style.cssText = `\n            position: absolute;\n            left: ${rect.left - 50}px;\n            top: ${rect.top - 50}px;\n            width: ${rect.width + 100}px;\n            height: ${rect.height + 100}px;\n            border: 1px solid rgba(0, 255, 255, 0.3);\n            border-radius: 50%;\n            animation: quantumField 2s ease-in-out infinite;\n            pointer-events: none;\n        `;\n        \n        const style = document.createElement('style');\n        style.textContent = `\n            @keyframes quantumField {\n                0%, 100% {\n                    transform: scale(1);\n                    opacity: 0.3;\n                    border-color: rgba(0, 255, 255, 0.3);\n                }\n                50% {\n                    transform: scale(1.1);\n                    opacity: 0.6;\n                    border-color: rgba(255, 0, 255, 0.6);\n                }\n            }\n        `;\n        \n        if (!document.getElementById('quantum-field-style')) {\n            style.id = 'quantum-field-style';\n            document.head.appendChild(style);\n        }\n        \n        this.hapticContainer.appendChild(field);\n        this.quantumField = field;\n        \n        setTimeout(() => {\n            if (this.quantumField) {\n                this.quantumField.remove();\n                this.quantumField = null;\n            }\n        }, 3000);\n    }\n    \n    createErrorShake() {\n        document.body.style.animation = 'errorShake 0.5s ease-in-out';\n        \n        const style = document.createElement('style');\n        style.textContent = `\n            @keyframes errorShake {\n                0%, 100% { transform: translateX(0); }\n                25% { transform: translateX(-10px); }\n                75% { transform: translateX(10px); }\n            }\n        `;\n        \n        if (!document.getElementById('error-shake-style')) {\n            style.id = 'error-shake-style';\n            document.head.appendChild(style);\n        }\n        \n        setTimeout(() => {\n            document.body.style.animation = '';\n        }, 500);\n    }\n    \n    monitorGamepads() {\n        setInterval(() => {\n            const gamepads = navigator.getGamepads();\n            // Monitor for gamepad button presses and trigger appropriate feedback\n            for (let gamepad of gamepads) {\n                if (gamepad) {\n                    // This would be expanded to handle gamepad-specific interactions\n                    // For now, we just ensure gamepad support is available\n                }\n            }\n        }, 100);\n    }\n    \n    animate() {\n        // Update any ongoing visual feedback animations\n        this.visualFeedback = this.visualFeedback.filter(feedback => {\n            feedback.update();\n            return !feedback.finished;\n        });\n        \n        requestAnimationFrame(() => this.animate());\n    }\n}\n\n// Initialize when DOM loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    const hapticFeedback = new HapticFeedback();\n    \n    // Make haptic feedback globally available\n    window.hapticFeedback = hapticFeedback;\n});