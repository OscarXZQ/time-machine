class CosmicRayAccelerator {
    constructor() {
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.cosmicRays = [];
        this.acceleratorRings = [];
        this.particleBeams = [];
        this.energyBuildup = [];
        this.collisionEvents = [];
        this.time = 0;
        this.accelerationField = 0;
        this.energyLevel = 0;
        this.maxEnergyLevel = 100;
        
        this.init();
        this.createAcceleratorSystems();
        this.animate();
    }
    
    init() {
        this.canvas.style.position = 'fixed';
        this.canvas.style.top = '0';
        this.canvas.style.left = '0';
        this.canvas.style.width = '100%';
        this.canvas.style.height = '100%';
        this.canvas.style.pointerEvents = 'none';
        this.canvas.style.zIndex = '480';
        this.canvas.style.mixBlendMode = 'screen';
        this.canvas.style.opacity = '0.6';
        
        this.resize();
        document.body.appendChild(this.canvas);
        
        this.bindEvents();
    }
    
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.createAcceleratorSystems();
    }
    
    bindEvents() {
        document.addEventListener('travel-start', () => {\n            this.initiateParticleAcceleration();\n            this.createHighEnergyEvent();\n        });\n        \n        document.addEventListener('calibrate-start', () => {\n            this.chargeAccelerator();\n        });\n        \n        document.addEventListener('mousemove', (e) => {\n            this.createCosmicInteraction(e.clientX, e.clientY);\n        });\n    }\n    \n    createAcceleratorSystems() {\n        this.acceleratorRings = [];\n        \n        // Create concentric accelerator rings\n        const centerX = this.canvas.width / 2;\n        const centerY = this.canvas.height / 2;\n        \n        for (let i = 0; i < 5; i++) {\n            this.acceleratorRings.push(new AcceleratorRing(\n                centerX,\n                centerY,\n                50 + i * 80,\n                i\n            ));\n        }\n        \n        // Create initial cosmic rays\n        for (let i = 0; i < 15; i++) {\n            this.cosmicRays.push(new CosmicRay(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height\n            ));\n        }\n        \n        // Create particle beams\n        for (let i = 0; i < 4; i++) {\n            const angle = (i / 4) * Math.PI * 2;\n            this.particleBeams.push(new ParticleBeam(\n                centerX + Math.cos(angle) * 200,\n                centerY + Math.sin(angle) * 200,\n                angle + Math.PI // pointing toward center\n            ));\n        }\n    }\n    \n    initiateParticleAcceleration() {\n        this.accelerationField = 5.0;\n        this.energyLevel = this.maxEnergyLevel;\n        \n        // Activate all accelerator rings\n        this.acceleratorRings.forEach(ring => ring.activate());\n        \n        // Create high-energy cosmic rays\n        for (let i = 0; i < 20; i++) {\n            this.cosmicRays.push(new CosmicRay(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height,\n                'high-energy'\n            ));\n        }\n        \n        // Intensify particle beams\n        this.particleBeams.forEach(beam => beam.intensify());\n    }\n    \n    createHighEnergyEvent() {\n        // Create massive particle collision at center\n        this.collisionEvents.push(new ParticleCollision(\n            this.canvas.width / 2,\n            this.canvas.height / 2,\n            'high-energy'\n        ));\n        \n        // Create energy buildup regions\n        for (let i = 0; i < 6; i++) {\n            const angle = (i / 6) * Math.PI * 2;\n            const distance = 150;\n            this.energyBuildup.push(new EnergyBuildup(\n                this.canvas.width / 2 + Math.cos(angle) * distance,\n                this.canvas.height / 2 + Math.sin(angle) * distance\n            ));\n        }\n    }\n    \n    chargeAccelerator() {\n        this.accelerationField = 2.0;\n        this.energyLevel = Math.min(this.maxEnergyLevel, this.energyLevel + 20);\n        \n        // Charge up accelerator rings\n        this.acceleratorRings.forEach(ring => ring.charge());\n    }\n    \n    createCosmicInteraction(x, y) {\n        if (Math.random() < 0.1) {\n            // Create cosmic ray at mouse position\n            this.cosmicRays.push(new CosmicRay(x, y, 'interactive'));\n            \n            // Small collision event\n            if (Math.random() < 0.3) {\n                this.collisionEvents.push(new ParticleCollision(x, y, 'minor'));\n            }\n        }\n    }\n    \n    update() {\n        this.time += 0.016;\n        \n        // Update all systems\n        this.acceleratorRings.forEach(ring => ring.update(this.time, this.accelerationField));\n        \n        this.cosmicRays = this.cosmicRays.filter(ray => {\n            ray.update(this.time, this.accelerationField);\n            return !ray.finished;\n        });\n        \n        this.particleBeams = this.particleBeams.filter(beam => {\n            beam.update(this.time, this.accelerationField);\n            return !beam.finished;\n        });\n        \n        this.energyBuildup = this.energyBuildup.filter(buildup => {\n            buildup.update(this.time);\n            return !buildup.finished;\n        });\n        \n        this.collisionEvents = this.collisionEvents.filter(collision => {\n            collision.update(this.time);\n            return !collision.finished;\n        });\n        \n        // Detect particle collisions\n        this.detectCollisions();\n        \n        // Energy decay\n        this.accelerationField *= 0.998;\n        this.energyLevel = Math.max(0, this.energyLevel - 0.1);\n        \n        // Spontaneous cosmic events\n        if (Math.random() < 0.008) {\n            this.createSpontaneousEvent();\n        }\n    }\n    \n    detectCollisions() {\n        // Check for cosmic ray collisions\n        for (let i = 0; i < this.cosmicRays.length; i++) {\n            for (let j = i + 1; j < this.cosmicRays.length; j++) {\n                const ray1 = this.cosmicRays[i];\n                const ray2 = this.cosmicRays[j];\n                \n                const dx = ray1.x - ray2.x;\n                const dy = ray1.y - ray2.y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                \n                if (distance < 20) {\n                    // Create collision event\n                    this.collisionEvents.push(new ParticleCollision(\n                        (ray1.x + ray2.x) / 2,\n                        (ray1.y + ray2.y) / 2,\n                        'cosmic-collision'\n                    ));\n                    \n                    // Remove collided rays\n                    ray1.finished = true;\n                    ray2.finished = true;\n                    break;\n                }\n            }\n        }\n    }\n    \n    createSpontaneousEvent() {\n        const eventType = Math.random();\n        \n        if (eventType < 0.4) {\n            // Cosmic ray burst\n            const centerX = Math.random() * this.canvas.width;\n            const centerY = Math.random() * this.canvas.height;\n            \n            for (let i = 0; i < 5; i++) {\n                this.cosmicRays.push(new CosmicRay(\n                    centerX + (Math.random() - 0.5) * 100,\n                    centerY + (Math.random() - 0.5) * 100,\n                    'burst'\n                ));\n            }\n        } else if (eventType < 0.7) {\n            // Energy buildup\n            this.energyBuildup.push(new EnergyBuildup(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height\n            ));\n        } else {\n            // Random collision\n            this.collisionEvents.push(new ParticleCollision(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height,\n                'spontaneous'\n            ));\n        }\n    }\n    \n    render() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        // Render accelerator field visualization\n        this.renderAcceleratorField();\n        \n        // Render accelerator rings\n        this.acceleratorRings.forEach(ring => ring.render(this.ctx));\n        \n        // Render energy buildup\n        this.energyBuildup.forEach(buildup => buildup.render(this.ctx));\n        \n        // Render particle beams\n        this.particleBeams.forEach(beam => beam.render(this.ctx));\n        \n        // Render cosmic rays\n        this.cosmicRays.forEach(ray => ray.render(this.ctx));\n        \n        // Render collision events\n        this.collisionEvents.forEach(collision => collision.render(this.ctx));\n        \n        // Render accelerator statistics\n        this.renderAcceleratorStats();\n    }\n    \n    renderAcceleratorField() {\n        if (this.accelerationField > 0.5) {\n            this.ctx.save();\n            \n            // Create field visualization\n            const gradient = this.ctx.createRadialGradient(\n                this.canvas.width / 2, this.canvas.height / 2, 0,\n                this.canvas.width / 2, this.canvas.height / 2, 300\n            );\n            gradient.addColorStop(0, `rgba(100, 200, 255, ${this.accelerationField * 0.1})`);\n            gradient.addColorStop(0.5, `rgba(200, 100, 255, ${this.accelerationField * 0.05})`);\n            gradient.addColorStop(1, 'transparent');\n            \n            this.ctx.fillStyle = gradient;\n            this.ctx.beginPath();\n            this.ctx.arc(this.canvas.width / 2, this.canvas.height / 2, 300, 0, Math.PI * 2);\n            this.ctx.fill();\n            \n            this.ctx.restore();\n        }\n    }\n    \n    renderAcceleratorStats() {\n        this.ctx.save();\n        this.ctx.font = '11px monospace';\n        this.ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';\n        \n        const energyPercent = ((this.energyLevel / this.maxEnergyLevel) * 100).toFixed(1);\n        const fieldStrength = this.accelerationField.toFixed(2);\n        const activeRays = this.cosmicRays.length;\n        const collisions = this.collisionEvents.length;\n        \n        this.ctx.fillText(`Energy Level: ${energyPercent}%`, 20, 30);\n        this.ctx.fillText(`Field Strength: ${fieldStrength}`, 20, 50);\n        this.ctx.fillText(`Active Cosmic Rays: ${activeRays}`, 20, 70);\n        this.ctx.fillText(`Active Collisions: ${collisions}`, 20, 90);\n        \n        // Energy level indicator\n        this.ctx.strokeStyle = 'rgba(100, 200, 255, 0.6)';\n        this.ctx.lineWidth = 2;\n        this.ctx.beginPath();\n        this.ctx.rect(20, 100, 200, 10);\n        this.ctx.stroke();\n        \n        this.ctx.fillStyle = `rgba(${this.energyLevel > 70 ? '255, 100, 100' : '100, 255, 100'}, 0.8)`;\n        this.ctx.fillRect(22, 102, (this.energyLevel / this.maxEnergyLevel) * 196, 6);\n        \n        this.ctx.restore();\n    }\n    \n    animate() {\n        this.update();\n        this.render();\n        requestAnimationFrame(() => this.animate());\n    }\n}\n\nclass AcceleratorRing {\n    constructor(x, y, radius, ringIndex) {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.ringIndex = ringIndex;\n        this.rotation = 0;\n        this.active = false;\n        this.energy = 0;\n        this.maxEnergy = 100;\n        this.magneticField = [];\n        this.electricField = [];\n        this.chargeLevel = 0;\n        \n        this.createFields();\n    }\n    \n    createFields() {\n        // Create magnetic field lines\n        for (let i = 0; i < 16; i++) {\n            const angle = (i / 16) * Math.PI * 2;\n            this.magneticField.push({\n                angle: angle,\n                strength: 0.5 + Math.random() * 0.5,\n                oscillation: 0\n            });\n        }\n        \n        // Create electric field points\n        for (let i = 0; i < 8; i++) {\n            const angle = (i / 8) * Math.PI * 2;\n            this.electricField.push({\n                angle: angle,\n                charge: Math.random() > 0.5 ? 1 : -1,\n                intensity: 0\n            });\n        }\n    }\n    \n    activate() {\n        this.active = true;\n        this.energy = this.maxEnergy;\n    }\n    \n    charge() {\n        this.chargeLevel = Math.min(100, this.chargeLevel + 20);\n        this.energy = Math.min(this.maxEnergy, this.energy + 15);\n    }\n    \n    update(time, accelerationField) {\n        this.rotation += 0.01 + (this.ringIndex * 0.005);\n        \n        // Update magnetic field\n        this.magneticField.forEach(field => {\n            field.oscillation += 0.05;\n        });\n        \n        // Update electric field\n        this.electricField.forEach(field => {\n            field.intensity = this.active ? this.energy / this.maxEnergy : 0.3;\n        });\n        \n        // Energy decay\n        if (this.active) {\n            this.energy *= 0.995;\n            if (this.energy < 10) {\n                this.active = false;\n            }\n        }\n        \n        this.chargeLevel *= 0.99;\n    }\n    \n    render(ctx) {\n        const alpha = this.active ? this.energy / this.maxEnergy : 0.4;\n        \n        ctx.save();\n        ctx.translate(this.x, this.y);\n        ctx.rotate(this.rotation);\n        \n        // Render magnetic field lines\n        ctx.strokeStyle = `rgba(0, 150, 255, ${alpha * 0.6})`;\n        ctx.lineWidth = 2;\n        ctx.shadowBlur = 8;\n        ctx.shadowColor = '#0096ff';\n        \n        this.magneticField.forEach(field => {\n            const fieldRadius = this.radius + Math.sin(field.oscillation) * 10;\n            const x1 = Math.cos(field.angle) * (fieldRadius - 15);\n            const y1 = Math.sin(field.angle) * (fieldRadius - 15);\n            const x2 = Math.cos(field.angle) * (fieldRadius + 15);\n            const y2 = Math.sin(field.angle) * (fieldRadius + 15);\n            \n            ctx.beginPath();\n            ctx.moveTo(x1, y1);\n            ctx.lineTo(x2, y2);\n            ctx.stroke();\n        });\n        \n        // Render electric field\n        this.electricField.forEach(field => {\n            const x = Math.cos(field.angle) * this.radius;\n            const y = Math.sin(field.angle) * this.radius;\n            \n            ctx.fillStyle = field.charge > 0 ?\n                `rgba(255, 100, 100, ${field.intensity * alpha})` :\n                `rgba(100, 100, 255, ${field.intensity * alpha})`;\n            ctx.shadowBlur = 10;\n            ctx.shadowColor = field.charge > 0 ? '#ff6464' : '#6464ff';\n            \n            ctx.beginPath();\n            ctx.arc(x, y, 4, 0, Math.PI * 2);\n            ctx.fill();\n            \n            // Charge indicator\n            ctx.font = '10px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;\n            ctx.textAlign = 'center';\n            ctx.fillText(field.charge > 0 ? '+' : '-', x, y + 3);\n        });\n        \n        // Render ring structure\n        ctx.strokeStyle = `rgba(150, 150, 255, ${alpha})`;\n        ctx.lineWidth = 3;\n        ctx.setLineDash([10, 5]);\n        \n        ctx.beginPath();\n        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);\n        ctx.stroke();\n        ctx.setLineDash([]);\n        \n        // Energy level indicator\n        if (this.active) {\n            ctx.font = '9px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;\n            ctx.textAlign = 'center';\n            ctx.fillText(`Ring ${this.ringIndex + 1}`, 0, -this.radius - 15);\n            ctx.fillText(`${Math.round(this.energy)}%`, 0, -this.radius - 5);\n        }\n        \n        ctx.restore();\n    }\n}\n\nclass CosmicRay {\n    constructor(x, y, type = 'normal') {\n        this.x = x;\n        this.y = y;\n        this.type = type;\n        this.vx = (Math.random() - 0.5) * (type === 'high-energy' ? 8 : 4);\n        this.vy = (Math.random() - 0.5) * (type === 'high-energy' ? 8 : 4);\n        this.energy = type === 'high-energy' ? 100 : 50;\n        this.maxEnergy = this.energy;\n        this.trail = [];\n        this.maxTrailLength = type === 'high-energy' ? 20 : 10;\n        this.finished = false;\n        this.life = type === 'interactive' ? 150 : 300;\n        this.maxLife = this.life;\n        this.ionization = [];\n        this.particleType = this.getRandomParticleType();\n        \n        this.createIonizationTrail();\n    }\n    \n    getRandomParticleType() {\n        const types = ['proton', 'electron', 'muon', 'neutrino', 'photon'];\n        return types[Math.floor(Math.random() * types.length)];\n    }\n    \n    createIonizationTrail() {\n        for (let i = 0; i < 5; i++) {\n            this.ionization.push({\n                x: 0,\n                y: 0,\n                life: 30,\n                maxLife: 30\n            });\n        }\n    }\n    \n    update(time, accelerationField) {\n        // Add current position to trail\n        this.trail.push({ x: this.x, y: this.y, energy: this.energy });\n        if (this.trail.length > this.maxTrailLength) {\n            this.trail.shift();\n        }\n        \n        // Acceleration field influence\n        const centerX = window.innerWidth / 2;\n        const centerY = window.innerHeight / 2;\n        const dx = centerX - this.x;\n        const dy = centerY - this.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        \n        if (distance > 0 && accelerationField > 0) {\n            const force = accelerationField * 0.01;\n            this.vx += (dx / distance) * force;\n            this.vy += (dy / distance) * force;\n        }\n        \n        // Movement\n        this.x += this.vx;\n        this.y += this.vy;\n        \n        // Update ionization trail\n        this.ionization.forEach((ion, index) => {\n            ion.x = this.x + (Math.random() - 0.5) * 10;\n            ion.y = this.y + (Math.random() - 0.5) * 10;\n            ion.life--;\n            \n            if (ion.life <= 0) {\n                ion.life = 30;\n            }\n        });\n        \n        // Energy loss from interactions\n        this.energy *= 0.999;\n        \n        // Boundary wrapping\n        if (this.x < -50) this.x = window.innerWidth + 50;\n        if (this.x > window.innerWidth + 50) this.x = -50;\n        if (this.y < -50) this.y = window.innerHeight + 50;\n        if (this.y > window.innerHeight + 50) this.y = -50;\n        \n        this.life--;\n        if (this.life <= 0 || this.energy < 5) {\n            this.finished = true;\n        }\n    }\n    \n    render(ctx) {\n        const alpha = (this.life / this.maxLife) * (this.energy / this.maxEnergy);\n        \n        // Render trail\n        this.trail.forEach((point, index) => {\n            const trailAlpha = (index / this.trail.length) * alpha * 0.6;\n            const trailSize = (index / this.trail.length) * 3;\n            \n            ctx.fillStyle = this.getParticleColor(trailAlpha);\n            ctx.shadowBlur = 3;\n            ctx.shadowColor = this.getParticleColor(1.0).replace(/[^,]+(?=\\))/, '1');\n            \n            ctx.beginPath();\n            ctx.arc(point.x, point.y, trailSize, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        // Render main particle\n        ctx.save();\n        ctx.fillStyle = this.getParticleColor(alpha);\n        ctx.shadowBlur = this.type === 'high-energy' ? 15 : 8;\n        ctx.shadowColor = this.getParticleColor(1.0).replace(/[^,]+(?=\\))/, '1');\n        \n        const size = this.type === 'high-energy' ? 4 : 2;\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, size, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Render ionization trail\n        this.ionization.forEach(ion => {\n            const ionAlpha = (ion.life / ion.maxLife) * alpha * 0.4;\n            \n            ctx.fillStyle = `rgba(255, 255, 100, ${ionAlpha})`;\n            ctx.beginPath();\n            ctx.arc(ion.x, ion.y, 1, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        // Particle type label (for high-energy particles)\n        if (this.type === 'high-energy' || this.type === 'interactive') {\n            ctx.font = '8px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;\n            ctx.textAlign = 'center';\n            ctx.fillText(this.particleType, this.x, this.y - 10);\n        }\n        \n        ctx.restore();\n    }\n    \n    getParticleColor(alpha) {\n        switch (this.particleType) {\n            case 'proton': return `rgba(255, 100, 100, ${alpha})`;\n            case 'electron': return `rgba(100, 100, 255, ${alpha})`;\n            case 'muon': return `rgba(255, 255, 100, ${alpha})`;\n            case 'neutrino': return `rgba(200, 200, 200, ${alpha})`;\n            case 'photon': return `rgba(255, 255, 255, ${alpha})`;\n            default: return `rgba(150, 255, 150, ${alpha})`;\n        }\n    }\n}\n\nclass ParticleBeam {\n    constructor(x, y, direction) {\n        this.startX = x;\n        this.startY = y;\n        this.direction = direction;\n        this.intensity = 0.5;\n        this.maxIntensity = 1.0;\n        this.finished = false;\n        this.beamParticles = [];\n        this.focusLevel = 1.0;\n        \n        this.createBeamParticles();\n    }\n    \n    createBeamParticles() {\n        for (let i = 0; i < 20; i++) {\n            this.beamParticles.push({\n                distance: i * 10,\n                offset: (Math.random() - 0.5) * 5,\n                energy: 1.0,\n                phase: Math.random() * Math.PI * 2\n            });\n        }\n    }\n    \n    intensify() {\n        this.intensity = this.maxIntensity;\n        this.focusLevel = 2.0;\n    }\n    \n    update(time, accelerationField) {\n        // Update beam particles\n        this.beamParticles.forEach(particle => {\n            particle.distance += 2;\n            particle.phase += 0.1;\n            particle.offset += Math.sin(particle.phase) * 0.5;\n            \n            // Reset particles that travel too far\n            if (particle.distance > 300) {\n                particle.distance = 0;\n                particle.offset = (Math.random() - 0.5) * 5;\n                particle.energy = 1.0;\n            }\n        });\n        \n        // Intensity decay\n        this.intensity *= 0.995;\n        this.focusLevel *= 0.998;\n        \n        if (this.intensity < 0.1) {\n            this.intensity = 0.3; // Maintain minimum beam\n        }\n    }\n    \n    render(ctx) {\n        if (this.intensity < 0.1) return;\n        \n        ctx.save();\n        ctx.translate(this.startX, this.startY);\n        \n        // Render beam core\n        const gradient = ctx.createLinearGradient(0, 0, Math.cos(this.direction) * 300, Math.sin(this.direction) * 300);\n        gradient.addColorStop(0, `rgba(100, 255, 255, ${this.intensity})`);\n        gradient.addColorStop(0.5, `rgba(255, 100, 255, ${this.intensity * 0.7})`);\n        gradient.addColorStop(1, 'transparent');\n        \n        ctx.strokeStyle = gradient;\n        ctx.lineWidth = 4 * this.focusLevel;\n        ctx.shadowBlur = 10 * this.intensity;\n        ctx.shadowColor = '#64ffff';\n        \n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(Math.cos(this.direction) * 300, Math.sin(this.direction) * 300);\n        ctx.stroke();\n        \n        // Render beam particles\n        this.beamParticles.forEach(particle => {\n            const x = Math.cos(this.direction) * particle.distance + Math.cos(this.direction + Math.PI/2) * particle.offset;\n            const y = Math.sin(this.direction) * particle.distance + Math.sin(this.direction + Math.PI/2) * particle.offset;\n            \n            const particleAlpha = particle.energy * this.intensity * (1 - particle.distance / 300);\n            \n            ctx.fillStyle = `rgba(255, 255, 255, ${particleAlpha})`;\n            ctx.shadowBlur = 5;\n            ctx.shadowColor = '#ffffff';\n            \n            ctx.beginPath();\n            ctx.arc(x, y, 1.5, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        ctx.restore();\n    }\n}\n\nclass EnergyBuildup {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.energy = 0;\n        this.maxEnergy = 100;\n        this.radius = 0;\n        this.maxRadius = 40;\n        this.finished = false;\n        this.life = 200;\n        this.maxLife = 200;\n        this.energyWaves = [];\n        this.plasmaArcs = [];\n        \n        this.createEnergyEffects();\n    }\n    \n    createEnergyEffects() {\n        for (let i = 0; i < 5; i++) {\n            this.energyWaves.push({\n                radius: 0,\n                speed: 1 + i * 0.2,\n                maxRadius: this.maxRadius + i * 10,\n                alpha: 1 - i * 0.15\n            });\n        }\n        \n        for (let i = 0; i < 8; i++) {\n            const angle = (i / 8) * Math.PI * 2;\n            this.plasmaArcs.push({\n                angle: angle,\n                length: 20 + Math.random() * 15,\n                oscillation: 0,\n                intensity: Math.random()\n            });\n        }\n    }\n    \n    update(time) {\n        // Energy buildup\n        if (this.life > this.maxLife * 0.5) {\n            this.energy = Math.min(this.maxEnergy, this.energy + 2);\n            this.radius = Math.min(this.maxRadius, this.radius + 1);\n        } else {\n            // Energy release\n            this.energy *= 0.95;\n            this.radius *= 0.98;\n        }\n        \n        // Update energy waves\n        this.energyWaves.forEach(wave => {\n            wave.radius += wave.speed;\n            if (wave.radius > wave.maxRadius) {\n                wave.radius = 0;\n            }\n        });\n        \n        // Update plasma arcs\n        this.plasmaArcs.forEach(arc => {\n            arc.oscillation += 0.15;\n            arc.intensity += (Math.random() - 0.5) * 0.2;\n            arc.intensity = Math.max(0.3, Math.min(1.0, arc.intensity));\n        });\n        \n        this.life--;\n        if (this.life <= 0) {\n            this.finished = true;\n        }\n    }\n    \n    render(ctx) {\n        const alpha = this.life / this.maxLife;\n        const energyRatio = this.energy / this.maxEnergy;\n        \n        ctx.save();\n        ctx.translate(this.x, this.y);\n        \n        // Render energy waves\n        this.energyWaves.forEach(wave => {\n            if (wave.radius > 0 && wave.radius <= wave.maxRadius) {\n                const waveAlpha = (1 - wave.radius / wave.maxRadius) * wave.alpha * alpha;\n                \n                ctx.strokeStyle = `rgba(255, 200, 0, ${waveAlpha})`;\n                ctx.lineWidth = 2;\n                ctx.shadowBlur = 8;\n                ctx.shadowColor = '#ffc800';\n                \n                ctx.beginPath();\n                ctx.arc(0, 0, wave.radius, 0, Math.PI * 2);\n                ctx.stroke();\n            }\n        });\n        \n        // Render plasma arcs\n        this.plasmaArcs.forEach(arc => {\n            const arcLength = arc.length + Math.sin(arc.oscillation) * 5;\n            const x = Math.cos(arc.angle) * arcLength;\n            const y = Math.sin(arc.angle) * arcLength;\n            \n            ctx.strokeStyle = `rgba(255, 100, 255, ${arc.intensity * alpha * energyRatio})`;\n            ctx.lineWidth = 3;\n            ctx.shadowBlur = 6;\n            ctx.shadowColor = '#ff64ff';\n            \n            ctx.beginPath();\n            ctx.moveTo(0, 0);\n            ctx.lineTo(x, y);\n            ctx.stroke();\n        });\n        \n        // Central energy core\n        if (this.energy > 0) {\n            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);\n            coreGradient.addColorStop(0, `rgba(255, 255, 100, ${energyRatio * alpha})`);\n            coreGradient.addColorStop(0.7, `rgba(255, 200, 0, ${energyRatio * alpha * 0.7})`);\n            coreGradient.addColorStop(1, 'transparent');\n            \n            ctx.fillStyle = coreGradient;\n            ctx.beginPath();\n            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        \n        // Energy level text\n        ctx.font = '10px monospace';\n        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;\n        ctx.textAlign = 'center';\n        ctx.fillText(`${Math.round(this.energy)}%`, 0, this.maxRadius + 15);\n        \n        ctx.restore();\n    }\n}\n\nclass ParticleCollision {\n    constructor(x, y, type = 'normal') {\n        this.x = x;\n        this.y = y;\n        this.type = type;\n        this.radius = 0;\n        this.maxRadius = type === 'high-energy' ? 100 : 50;\n        this.finished = false;\n        this.life = type === 'high-energy' ? 120 : 60;\n        this.maxLife = this.life;\n        this.shockWaves = [];\n        this.debris = [];\n        \n        this.createCollisionEffects();\n    }\n    \n    createCollisionEffects() {\n        // Create shockwaves\n        const waveCount = this.type === 'high-energy' ? 6 : 3;\n        for (let i = 0; i < waveCount; i++) {\n            this.shockWaves.push({\n                radius: 0,\n                speed: 2 + i * 0.5,\n                maxRadius: this.maxRadius + i * 20,\n                alpha: 1 - i * 0.15\n            });\n        }\n        \n        // Create debris particles\n        const debrisCount = this.type === 'high-energy' ? 20 : 10;\n        for (let i = 0; i < debrisCount; i++) {\n            const angle = Math.random() * Math.PI * 2;\n            const speed = 2 + Math.random() * 4;\n            \n            this.debris.push({\n                x: 0,\n                y: 0,\n                vx: Math.cos(angle) * speed,\n                vy: Math.sin(angle) * speed,\n                life: 40 + Math.random() * 20,\n                maxLife: 40 + Math.random() * 20,\n                size: 1 + Math.random() * 2\n            });\n        }\n    }\n    \n    update(time) {\n        // Update shockwaves\n        this.shockWaves.forEach(wave => {\n            wave.radius += wave.speed;\n        });\n        \n        // Update debris\n        this.debris = this.debris.filter(particle => {\n            particle.x += particle.vx;\n            particle.y += particle.vy;\n            particle.vx *= 0.98; // Friction\n            particle.vy *= 0.98;\n            particle.life--;\n            \n            return particle.life > 0;\n        });\n        \n        this.life--;\n        if (this.life <= 0) {\n            this.finished = true;\n        }\n    }\n    \n    render(ctx) {\n        const alpha = this.life / this.maxLife;\n        \n        ctx.save();\n        ctx.translate(this.x, this.y);\n        \n        // Render shockwaves\n        this.shockWaves.forEach(wave => {\n            if (wave.radius <= wave.maxRadius) {\n                const waveAlpha = (1 - wave.radius / wave.maxRadius) * wave.alpha * alpha;\n                \n                ctx.strokeStyle = `rgba(255, 255, 255, ${waveAlpha})`;\n                ctx.lineWidth = this.type === 'high-energy' ? 4 : 2;\n                ctx.shadowBlur = 15;\n                ctx.shadowColor = '#ffffff';\n                \n                ctx.beginPath();\n                ctx.arc(0, 0, wave.radius, 0, Math.PI * 2);\n                ctx.stroke();\n            }\n        });\n        \n        // Render debris\n        this.debris.forEach(particle => {\n            const particleAlpha = (particle.life / particle.maxLife) * alpha;\n            \n            ctx.fillStyle = `rgba(255, 200, 100, ${particleAlpha})`;\n            ctx.shadowBlur = 5;\n            ctx.shadowColor = '#ffc864';\n            \n            ctx.beginPath();\n            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        // Central explosion flash\n        if (this.life > this.maxLife * 0.8) {\n            const flashIntensity = (this.life - this.maxLife * 0.8) / (this.maxLife * 0.2);\n            \n            ctx.fillStyle = `rgba(255, 255, 255, ${flashIntensity})`;\n            ctx.shadowBlur = 20;\n            ctx.shadowColor = '#ffffff';\n            \n            ctx.beginPath();\n            ctx.arc(0, 0, 10, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        \n        // Collision type indicator\n        if (this.type !== 'normal') {\n            ctx.font = '8px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;\n            ctx.textAlign = 'center';\n            ctx.fillText(this.type.toUpperCase(), 0, this.maxRadius + 15);\n        }\n        \n        ctx.restore();\n    }\n}\n\n// Initialize when DOM loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    new CosmicRayAccelerator();\n});