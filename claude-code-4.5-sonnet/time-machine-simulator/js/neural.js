class NeuralNetworkVisualizer {\n    constructor() {\n        this.canvas = document.createElement('canvas');\n        this.ctx = this.canvas.getContext('2d');\n        this.neurons = [];\n        this.connections = [];\n        this.synapses = [];\n        this.brainwaves = [];\n        this.cognitionClouds = [];\n        this.time = 0;\n        this.networkActive = false;\n        \n        this.init();\n        this.createNeuralNetwork();\n        this.animate();\n    }\n    \n    init() {\n        this.canvas.style.position = 'fixed';\n        this.canvas.style.top = '0';\n        this.canvas.style.left = '0';\n        this.canvas.style.width = '100%';\n        this.canvas.style.height = '100%';\n        this.canvas.style.pointerEvents = 'none';\n        this.canvas.style.zIndex = '350';\n        this.canvas.style.mixBlendMode = 'screen';\n        this.canvas.style.opacity = '0.3';\n        \n        this.resize();\n        document.body.appendChild(this.canvas);\n    }\n    \n    resize() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n    }\n    \n    createNeuralNetwork() {\n        // Create multiple neural clusters\n        this.createNeuralCluster(this.canvas.width * 0.2, this.canvas.height * 0.3, 15, 'temporal');\n        this.createNeuralCluster(this.canvas.width * 0.8, this.canvas.height * 0.7, 12, 'spatial');\n        this.createNeuralCluster(this.canvas.width * 0.5, this.canvas.height * 0.2, 18, 'quantum');\n        this.createNeuralCluster(this.canvas.width * 0.3, this.canvas.height * 0.8, 10, 'dimensional');\n        this.createNeuralCluster(this.canvas.width * 0.7, this.canvas.height * 0.4, 14, 'consciousness');\n        \n        // Create inter-cluster connections\n        this.createInterClusterConnections();\n        \n        // Initialize brainwave patterns\n        this.initializeBrainwaves();\n        \n        // Create cognition clouds\n        this.createCognitionClouds();\n    }\n    \n    createNeuralCluster(centerX, centerY, neuronCount, type) {\n        const cluster = [];\n        const radius = 100 + Math.random() * 50;\n        \n        for (let i = 0; i < neuronCount; i++) {\n            const angle = (i / neuronCount) * Math.PI * 2;\n            const distance = Math.random() * radius;\n            const x = centerX + Math.cos(angle) * distance;\n            const y = centerY + Math.sin(angle) * distance;\n            \n            const neuron = new Neuron(x, y, type);\n            cluster.push(neuron);\n            this.neurons.push(neuron);\n        }\n        \n        // Connect neurons within cluster\n        for (let i = 0; i < cluster.length; i++) {\n            for (let j = i + 1; j < cluster.length; j++) {\n                if (Math.random() < 0.3) {\n                    const connection = new NeuralConnection(cluster[i], cluster[j]);\n                    this.connections.push(connection);\n                }\n            }\n        }\n        \n        return cluster;\n    }\n    \n    createInterClusterConnections() {\n        // Connect different clusters with long-range connections\n        for (let i = 0; i < this.neurons.length; i++) {\n            for (let j = i + 1; j < this.neurons.length; j++) {\n                const neuron1 = this.neurons[i];\n                const neuron2 = this.neurons[j];\n                \n                if (neuron1.type !== neuron2.type && Math.random() < 0.05) {\n                    const connection = new NeuralConnection(neuron1, neuron2, true);\n                    this.connections.push(connection);\n                }\n            }\n        }\n    }\n    \n    initializeBrainwaves() {\n        // Different brainwave frequencies\n        const frequencies = [\n            { name: 'alpha', freq: 0.1, color: '#00ffff', amplitude: 30 },\n            { name: 'beta', freq: 0.2, color: '#ff00ff', amplitude: 20 },\n            { name: 'gamma', freq: 0.4, color: '#ffff00', amplitude: 15 },\n            { name: 'theta', freq: 0.07, color: '#00ff00', amplitude: 40 },\n            { name: 'delta', freq: 0.03, color: '#ff6600', amplitude: 50 }\n        ];\n        \n        frequencies.forEach(wave => {\n            this.brainwaves.push(new Brainwave(wave.name, wave.freq, wave.color, wave.amplitude));\n        });\n    }\n    \n    createCognitionClouds() {\n        for (let i = 0; i < 8; i++) {\n            this.cognitionClouds.push(new CognitionCloud(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height\n            ));\n        }\n    }\n    \n    activateNetwork() {\n        this.networkActive = true;\n        \n        // Trigger cascade activation\n        const seedNeuron = this.neurons[Math.floor(Math.random() * this.neurons.length)];\n        seedNeuron.activate();\n        \n        // Start synaptic activity\n        this.startSynapticBursts();\n        \n        // Enhance brainwave activity\n        this.brainwaves.forEach(wave => wave.amplify(2.0));\n    }\n    \n    deactivateNetwork() {\n        this.networkActive = false;\n        \n        // Gradual deactivation\n        this.neurons.forEach(neuron => neuron.deactivate());\n        this.brainwaves.forEach(wave => wave.amplify(0.5));\n    }\n    \n    startSynapticBursts() {\n        if (!this.networkActive) return;\n        \n        // Create random synaptic bursts\n        for (let i = 0; i < 5; i++) {\n            setTimeout(() => {\n                const connection = this.connections[Math.floor(Math.random() * this.connections.length)];\n                if (connection) {\n                    const synapse = new Synapse(connection.from, connection.to);\n                    this.synapses.push(synapse);\n                }\n            }, Math.random() * 1000);\n        }\n        \n        if (this.networkActive) {\n            setTimeout(() => this.startSynapticBursts(), 2000 + Math.random() * 3000);\n        }\n    }\n    \n    update() {\n        this.time += 0.016;\n        \n        // Update neurons\n        this.neurons.forEach(neuron => neuron.update(this.time));\n        \n        // Update connections\n        this.connections.forEach(connection => connection.update(this.time));\n        \n        // Update synapses\n        this.synapses = this.synapses.filter(synapse => {\n            synapse.update();\n            return !synapse.finished;\n        });\n        \n        // Update brainwaves\n        this.brainwaves.forEach(wave => wave.update(this.time));\n        \n        // Update cognition clouds\n        this.cognitionClouds.forEach(cloud => cloud.update(this.time));\n        \n        // Neural propagation\n        this.propagateActivation();\n    }\n    \n    propagateActivation() {\n        this.neurons.forEach(neuron => {\n            if (neuron.isActive && Math.random() < 0.1) {\n                // Find connected neurons and potentially activate them\n                this.connections.forEach(connection => {\n                    if (connection.from === neuron && Math.random() < 0.3) {\n                        connection.to.activate();\n                        \n                        // Create synapse visualization\n                        const synapse = new Synapse(connection.from, connection.to);\n                        this.synapses.push(synapse);\n                    }\n                });\n            }\n        });\n    }\n    \n    render() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        // Render brainwaves first (background)\n        this.brainwaves.forEach(wave => wave.render(this.ctx, this.canvas.width, this.canvas.height));\n        \n        // Render cognition clouds\n        this.cognitionClouds.forEach(cloud => cloud.render(this.ctx));\n        \n        // Render connections\n        this.connections.forEach(connection => connection.render(this.ctx));\n        \n        // Render synapses\n        this.synapses.forEach(synapse => synapse.render(this.ctx));\n        \n        // Render neurons\n        this.neurons.forEach(neuron => neuron.render(this.ctx));\n        \n        // Render network statistics\n        this.renderNetworkStats();\n    }\n    \n    renderNetworkStats() {\n        const activeNeurons = this.neurons.filter(n => n.isActive).length;\n        const activeSynapses = this.synapses.length;\n        \n        this.ctx.save();\n        this.ctx.font = '12px monospace';\n        this.ctx.fillStyle = 'rgba(0, 255, 255, 0.6)';\n        this.ctx.fillText(`Active Neurons: ${activeNeurons}`, 20, 30);\n        this.ctx.fillText(`Synaptic Activity: ${activeSynapses}`, 20, 50);\n        this.ctx.fillText(`Network State: ${this.networkActive ? 'ACTIVE' : 'IDLE'}`, 20, 70);\n        this.ctx.restore();\n    }\n    \n    animate() {\n        this.update();\n        this.render();\n        requestAnimationFrame(() => this.animate());\n    }\n}\n\nclass Neuron {\n    constructor(x, y, type) {\n        this.x = x;\n        this.y = y;\n        this.type = type;\n        this.size = 3 + Math.random() * 4;\n        this.baseSize = this.size;\n        this.isActive = false;\n        this.activationLevel = 0;\n        this.activationDecay = 0.02;\n        this.pulsePhase = Math.random() * Math.PI * 2;\n        this.dendrites = [];\n        \n        this.colors = {\n            temporal: '#00ffff',\n            spatial: '#ff00ff',\n            quantum: '#ffff00',\n            dimensional: '#00ff00',\n            consciousness: '#ff6600'\n        };\n        \n        this.color = this.colors[type] || '#ffffff';\n        \n        // Create dendrite branches\n        this.createDendrites();\n    }\n    \n    createDendrites() {\n        const branchCount = 3 + Math.floor(Math.random() * 5);\n        \n        for (let i = 0; i < branchCount; i++) {\n            const angle = (i / branchCount) * Math.PI * 2 + Math.random() * 0.5;\n            const length = 15 + Math.random() * 20;\n            \n            this.dendrites.push({\n                angle: angle,\n                length: length,\n                thickness: 1 + Math.random() * 2,\n                activity: 0\n            });\n        }\n    }\n    \n    activate() {\n        this.isActive = true;\n        this.activationLevel = 1.0;\n    }\n    \n    deactivate() {\n        this.isActive = false;\n    }\n    \n    update(time) {\n        // Update activation level\n        if (this.isActive) {\n            this.activationLevel = Math.max(0, this.activationLevel - this.activationDecay);\n            if (this.activationLevel <= 0) {\n                this.isActive = false;\n            }\n        }\n        \n        // Update size based on activation\n        this.size = this.baseSize + this.activationLevel * 3;\n        \n        // Update pulse phase\n        this.pulsePhase += 0.1;\n        \n        // Update dendrite activity\n        this.dendrites.forEach(dendrite => {\n            if (this.isActive) {\n                dendrite.activity = Math.min(1, dendrite.activity + 0.1);\n            } else {\n                dendrite.activity = Math.max(0, dendrite.activity - 0.05);\n            }\n        });\n    }\n    \n    render(ctx) {\n        ctx.save();\n        \n        // Render dendrites\n        this.dendrites.forEach(dendrite => {\n            if (dendrite.activity > 0) {\n                ctx.strokeStyle = this.color.replace(')', `, ${dendrite.activity * 0.6})`);\n                ctx.lineWidth = dendrite.thickness;\n                ctx.shadowBlur = 5;\n                ctx.shadowColor = this.color;\n                \n                ctx.beginPath();\n                ctx.moveTo(this.x, this.y);\n                const endX = this.x + Math.cos(dendrite.angle) * dendrite.length;\n                const endY = this.y + Math.sin(dendrite.angle) * dendrite.length;\n                ctx.lineTo(endX, endY);\n                ctx.stroke();\n                \n                // Render synaptic terminals\n                ctx.fillStyle = this.color.replace(')', `, ${dendrite.activity * 0.8})`);\n                ctx.beginPath();\n                ctx.arc(endX, endY, 2, 0, Math.PI * 2);\n                ctx.fill();\n            }\n        });\n        \n        // Render neuron body\n        const alpha = 0.6 + this.activationLevel * 0.4;\n        const pulseSize = this.size + Math.sin(this.pulsePhase) * 2;\n        \n        // Outer glow\n        ctx.shadowBlur = 15 + this.activationLevel * 10;\n        ctx.shadowColor = this.color;\n        \n        // Gradient fill\n        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, pulseSize);\n        gradient.addColorStop(0, this.color.replace(')', `, ${alpha})`);\n        gradient.addColorStop(0.7, this.color.replace(')', `, ${alpha * 0.5})`);\n        gradient.addColorStop(1, 'transparent');\n        \n        ctx.fillStyle = gradient;\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, pulseSize, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Core\n        if (this.isActive) {\n            ctx.fillStyle = '#ffffff';\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        \n        ctx.restore();\n    }\n}\n\nclass NeuralConnection {\n    constructor(from, to, isLongRange = false) {\n        this.from = from;\n        this.to = to;\n        this.isLongRange = isLongRange;\n        this.strength = 0.3 + Math.random() * 0.7;\n        this.activity = 0;\n        this.lastActivity = 0;\n    }\n    \n    update(time) {\n        // Update connection strength based on usage\n        if (this.from.isActive || this.to.isActive) {\n            this.activity = Math.min(1, this.activity + 0.1);\n            this.lastActivity = time;\n        } else if (time - this.lastActivity > 2) {\n            this.activity = Math.max(0, this.activity - 0.02);\n        }\n    }\n    \n    render(ctx) {\n        if (this.activity <= 0) return;\n        \n        ctx.save();\n        \n        const alpha = this.activity * this.strength * (this.isLongRange ? 0.3 : 0.6);\n        const color = this.isLongRange ? '#8888ff' : '#cccccc';\n        \n        ctx.strokeStyle = color.replace(')', `, ${alpha})`) || `rgba(200, 200, 200, ${alpha})`;\n        ctx.lineWidth = this.isLongRange ? 1 : 2;\n        ctx.shadowBlur = 3;\n        ctx.shadowColor = color;\n        \n        ctx.beginPath();\n        ctx.moveTo(this.from.x, this.from.y);\n        \n        // Create curved connection\n        const midX = (this.from.x + this.to.x) / 2;\n        const midY = (this.from.y + this.to.y) / 2;\n        const curvature = this.isLongRange ? 50 : 20;\n        \n        ctx.quadraticCurveTo(\n            midX + (Math.random() - 0.5) * curvature,\n            midY + (Math.random() - 0.5) * curvature,\n            this.to.x,\n            this.to.y\n        );\n        \n        ctx.stroke();\n        ctx.restore();\n    }\n}\n\nclass Synapse {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n        this.progress = 0;\n        this.speed = 0.02 + Math.random() * 0.03;\n        this.finished = false;\n        this.size = 3 + Math.random() * 2;\n        this.color = '#ffffff';\n        this.trail = [];\n        this.maxTrailLength = 8;\n    }\n    \n    update() {\n        this.progress += this.speed;\n        \n        // Calculate current position\n        const x = this.from.x + (this.to.x - this.from.x) * this.progress;\n        const y = this.from.y + (this.to.y - this.from.y) * this.progress;\n        \n        // Add to trail\n        this.trail.unshift({ x, y, alpha: 1 });\n        if (this.trail.length > this.maxTrailLength) {\n            this.trail.pop();\n        }\n        \n        // Decay trail\n        this.trail.forEach((point, index) => {\n            point.alpha = 1 - (index / this.maxTrailLength);\n        });\n        \n        if (this.progress >= 1) {\n            this.finished = true;\n            // Activate target neuron\n            this.to.activate();\n        }\n    }\n    \n    render(ctx) {\n        ctx.save();\n        \n        // Render trail\n        this.trail.forEach((point, index) => {\n            const size = this.size * point.alpha;\n            ctx.fillStyle = `rgba(255, 255, 255, ${point.alpha * 0.8})`;\n            ctx.shadowBlur = 10;\n            ctx.shadowColor = '#00ffff';\n            \n            ctx.beginPath();\n            ctx.arc(point.x, point.y, size, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        ctx.restore();\n    }\n}\n\nclass Brainwave {\n    constructor(name, frequency, color, amplitude) {\n        this.name = name;\n        this.frequency = frequency;\n        this.color = color;\n        this.amplitude = amplitude;\n        this.baseAmplitude = amplitude;\n        this.phase = 0;\n        this.amplifier = 1;\n    }\n    \n    update(time) {\n        this.phase = time * this.frequency;\n    }\n    \n    amplify(factor) {\n        this.amplifier = factor;\n    }\n    \n    render(ctx, width, height) {\n        ctx.save();\n        ctx.strokeStyle = this.color.replace(')', ', 0.2)') || `${this.color}33`;\n        ctx.lineWidth = 2;\n        ctx.shadowBlur = 5;\n        ctx.shadowColor = this.color;\n        \n        ctx.beginPath();\n        \n        for (let x = 0; x < width; x += 5) {\n            const normalizedX = x / width;\n            const y = height / 2 + \n                Math.sin(this.phase + normalizedX * Math.PI * 4) * \n                this.amplitude * this.amplifier;\n            \n            if (x === 0) {\n                ctx.moveTo(x, y);\n            } else {\n                ctx.lineTo(x, y);\n            }\n        }\n        \n        ctx.stroke();\n        ctx.restore();\n    }\n}\n\nclass CognitionCloud {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.size = 50 + Math.random() * 100;\n        this.particles = [];\n        this.thoughtBubbles = [];\n        this.intensity = 0.3 + Math.random() * 0.4;\n        \n        this.createParticles();\n        this.createThoughtBubbles();\n    }\n    \n    createParticles() {\n        for (let i = 0; i < 20; i++) {\n            this.particles.push({\n                x: (Math.random() - 0.5) * this.size * 2,\n                y: (Math.random() - 0.5) * this.size * 2,\n                vx: (Math.random() - 0.5) * 0.5,\n                vy: (Math.random() - 0.5) * 0.5,\n                size: Math.random() * 3 + 1,\n                life: Math.random() * 100 + 50,\n                maxLife: 150\n            });\n        }\n    }\n    \n    createThoughtBubbles() {\n        for (let i = 0; i < 5; i++) {\n            this.thoughtBubbles.push({\n                x: (Math.random() - 0.5) * this.size,\n                y: (Math.random() - 0.5) * this.size,\n                size: Math.random() * 15 + 5,\n                phase: Math.random() * Math.PI * 2,\n                speed: 0.02 + Math.random() * 0.03\n            });\n        }\n    }\n    \n    update(time) {\n        // Update particles\n        this.particles.forEach(particle => {\n            particle.x += particle.vx;\n            particle.y += particle.vy;\n            particle.life--;\n            \n            if (particle.life <= 0) {\n                particle.x = (Math.random() - 0.5) * this.size * 2;\n                particle.y = (Math.random() - 0.5) * this.size * 2;\n                particle.life = particle.maxLife;\n            }\n        });\n        \n        // Update thought bubbles\n        this.thoughtBubbles.forEach(bubble => {\n            bubble.phase += bubble.speed;\n            bubble.x += Math.sin(bubble.phase) * 0.1;\n            bubble.y += Math.cos(bubble.phase) * 0.1;\n        });\n    }\n    \n    render(ctx) {\n        ctx.save();\n        \n        // Render cognition field\n        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);\n        gradient.addColorStop(0, `rgba(100, 150, 255, ${this.intensity * 0.3})`);\n        gradient.addColorStop(0.5, `rgba(150, 100, 255, ${this.intensity * 0.2})`);\n        gradient.addColorStop(1, 'transparent');\n        \n        ctx.fillStyle = gradient;\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Render particles\n        this.particles.forEach(particle => {\n            const alpha = (particle.life / particle.maxLife) * this.intensity;\n            ctx.fillStyle = `rgba(200, 150, 255, ${alpha})`;\n            ctx.beginPath();\n            ctx.arc(this.x + particle.x, this.y + particle.y, particle.size, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        // Render thought bubbles\n        this.thoughtBubbles.forEach(bubble => {\n            ctx.strokeStyle = `rgba(255, 255, 255, ${this.intensity * 0.6})`;\n            ctx.lineWidth = 1;\n            ctx.beginPath();\n            ctx.arc(\n                this.x + bubble.x,\n                this.y + bubble.y,\n                bubble.size + Math.sin(bubble.phase * 2) * 3,\n                0,\n                Math.PI * 2\n            );\n            ctx.stroke();\n        });\n        \n        ctx.restore();\n    }\n}\n\n// Initialize when DOM loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    const neuralNetwork = new NeuralNetworkVisualizer();\n    \n    // Bind events\n    document.addEventListener('travel-start', () => {\n        neuralNetwork.activateNetwork();\n    });\n    \n    document.addEventListener('arrival-complete', () => {\n        neuralNetwork.deactivateNetwork();\n    });\n    \n    document.addEventListener('calibrate-start', () => {\n        neuralNetwork.activateNetwork();\n        setTimeout(() => neuralNetwork.deactivateNetwork(), 2000);\n    });\n    \n    window.addEventListener('resize', () => {\n        neuralNetwork.resize();\n    });\n});