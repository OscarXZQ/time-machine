class CinematicCamera {\n    constructor() {\n        this.position = { x: 0, y: 0, z: 0 };\n        this.target = { x: 0, y: 0, z: 0 };\n        this.rotation = { x: 0, y: 0, z: 0 };\n        this.fov = 75;\n        this.shake = { intensity: 0, frequency: 0 };\n        this.transitions = [];\n        this.currentSequence = null;\n        \n        this.init();\n        this.animate();\n    }\n    \n    init() {\n        this.bindEvents();\n        this.createCameraRig();\n    }\n    \n    createCameraRig() {\n        // Virtual camera container for transformations\n        this.cameraContainer = document.createElement('div');\n        this.cameraContainer.style.cssText = `\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            pointer-events: none;\n            z-index: 10000;\n            transform-style: preserve-3d;\n            perspective: 1000px;\n        `;\n        \n        document.body.appendChild(this.cameraContainer);\n    }\n    \n    bindEvents() {\n        document.addEventListener('travel-start', () => {\n            this.startTravelSequence();\n        });\n        \n        document.addEventListener('calibrate-start', () => {\n            this.startCalibrateSequence();\n        });\n        \n        document.addEventListener('arrival-complete', () => {\n            this.startArrivalSequence();\n        });\n    }\n    \n    startTravelSequence() {\n        this.currentSequence = [\n            // Initial dramatic zoom\n            {\n                duration: 1000,\n                type: 'zoom',\n                from: { fov: 75 },\n                to: { fov: 120 },\n                easing: 'easeOutQuad'\n            },\n            // Orbital movement around flux capacitor\n            {\n                duration: 2000,\n                type: 'orbit',\n                center: { x: window.innerWidth / 2, y: window.innerHeight / 2 },\n                radius: 300,\n                rotations: 1.5,\n                easing: 'easeInOutCubic'\n            },\n            // Dimensional shift effect\n            {\n                duration: 1500,\n                type: 'dimensionalShift',\n                intensity: 2.0,\n                easing: 'easeInOutQuart'\n            },\n            // Final zoom out\n            {\n                duration: 1000,\n                type: 'zoom',\n                from: { fov: 120 },\n                to: { fov: 75 },\n                easing: 'easeInQuad'\n            }\n        ];\n        \n        this.executeSequence();\n    }\n    \n    startCalibrateSequence() {\n        this.currentSequence = [\n            // Precision focus\n            {\n                duration: 800,\n                type: 'focus',\n                target: '.flux-center',\n                intensity: 1.5,\n                easing: 'easeOutCubic'\n            },\n            // Subtle rotation\n            {\n                duration: 1000,\n                type: 'rotate',\n                axis: 'z',\n                angle: 360,\n                easing: 'easeInOutSine'\n            }\n        ];\n        \n        this.executeSequence();\n    }\n    \n    startArrivalSequence() {\n        this.currentSequence = [\n            // Dramatic emergence\n            {\n                duration: 1200,\n                type: 'emerge',\n                from: { scale: 0.1, blur: 20 },\n                to: { scale: 1.0, blur: 0 },\n                easing: 'easeOutBack'\n            },\n            // Stabilization\n            {\n                duration: 800,\n                type: 'stabilize',\n                easing: 'easeOutBounce'\n            }\n        ];\n        \n        this.executeSequence();\n    }\n    \n    executeSequence() {\n        if (!this.currentSequence || this.currentSequence.length === 0) return;\n        \n        const step = this.currentSequence.shift();\n        this.executeStep(step).then(() => {\n            if (this.currentSequence.length > 0) {\n                this.executeSequence();\n            } else {\n                this.resetCamera();\n            }\n        });\n    }\n    \n    executeStep(step) {\n        return new Promise((resolve) => {\n            const startTime = Date.now();\n            const animate = () => {\n                const elapsed = Date.now() - startTime;\n                const progress = Math.min(elapsed / step.duration, 1);\n                const easedProgress = this.applyEasing(progress, step.easing || 'linear');\n                \n                this.applyStepEffect(step, easedProgress);\n                \n                if (progress < 1) {\n                    requestAnimationFrame(animate);\n                } else {\n                    resolve();\n                }\n            };\n            \n            animate();\n        });\n    }\n    \n    applyStepEffect(step, progress) {\n        switch (step.type) {\n            case 'zoom':\n                this.applyZoom(step, progress);\n                break;\n            case 'orbit':\n                this.applyOrbit(step, progress);\n                break;\n            case 'dimensionalShift':\n                this.applyDimensionalShift(step, progress);\n                break;\n            case 'focus':\n                this.applyFocus(step, progress);\n                break;\n            case 'rotate':\n                this.applyRotation(step, progress);\n                break;\n            case 'emerge':\n                this.applyEmergence(step, progress);\n                break;\n            case 'stabilize':\n                this.applyStabilization(step, progress);\n                break;\n        }\n    }\n    \n    applyZoom(step, progress) {\n        const fromFov = step.from.fov;\n        const toFov = step.to.fov;\n        const currentFov = fromFov + (toFov - fromFov) * progress;\n        \n        document.body.style.perspective = (1000 / (currentFov / 75)) + 'px';\n        \n        // Add zoom shake effect\n        if (progress > 0.7) {\n            this.addShake(0.5, 20);\n        }\n    }\n    \n    applyOrbit(step, progress) {\n        const angle = progress * Math.PI * 2 * step.rotations;\n        const x = step.center.x + Math.cos(angle) * step.radius * (1 - progress * 0.3);\n        const y = step.center.y + Math.sin(angle) * step.radius * 0.3;\n        \n        const container = document.querySelector('.time-machine-container');\n        if (container) {\n            container.style.transformOrigin = `${step.center.x}px ${step.center.y}px`;\n            container.style.transform = `\n                perspective(1000px)\n                rotateY(${angle * 180 / Math.PI * 0.3}deg)\n                rotateX(${Math.sin(angle * 2) * 5}deg)\n                translateZ(${Math.sin(progress * Math.PI) * 50}px)\n            `;\n        }\n        \n        // Add orbital motion effects to UI\n        this.applyOrbitalEffects(progress, angle);\n    }\n    \n    applyOrbitalEffects(progress, angle) {\n        // Flux capacitor follows orbital motion\n        const fluxCapacitor = document.querySelector('.flux-capacitor');\n        if (fluxCapacitor) {\n            fluxCapacitor.style.transform = `\n                rotateX(${Math.sin(angle) * 10}deg)\n                rotateY(${angle * 180 / Math.PI * 0.5}deg)\n                scale(${1 + Math.sin(progress * Math.PI) * 0.1})\n            `;\n        }\n        \n        // Status panels react to camera movement\n        document.querySelectorAll('.status-item').forEach((item, index) => {\n            item.style.transform = `\n                translateX(${Math.sin(angle + index) * 10}px)\n                rotateZ(${Math.cos(angle + index) * 2}deg)\n            `;\n        });\n    }\n    \n    applyDimensionalShift(step, progress) {\n        const intensity = step.intensity * Math.sin(progress * Math.PI);\n        \n        // Reality distortion effects\n        document.body.style.filter = `\n            hue-rotate(${intensity * 30}deg)\n            blur(${intensity * 2}px)\n            brightness(${1 + intensity * 0.3})\n            contrast(${1 + intensity * 0.5})\n        `;\n        \n        // Dimensional fracture overlay\n        this.createDimensionalFracture(intensity);\n        \n        // Temporal displacement of UI elements\n        this.applyTemporalDisplacement(intensity);\n    }\n    \n    createDimensionalFracture(intensity) {\n        if (intensity < 0.1) return;\n        \n        const fracture = document.createElement('div');\n        fracture.className = 'dimensional-fracture';\n        fracture.style.cssText = `\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            pointer-events: none;\n            z-index: 15000;\n            background: \n                linear-gradient(${Math.random() * 360}deg, \n                    transparent ${40 + Math.random() * 20}%, \n                    rgba(255,255,255,${intensity * 0.3}) ${50}%, \n                    transparent ${60 + Math.random() * 20}%),\n                radial-gradient(circle at ${Math.random() * 100}% ${Math.random() * 100}%, \n                    rgba(0,255,255,${intensity * 0.2}) 0%, \n                    transparent 30%);\n            animation: dimensionalFlicker 0.1s ease-in-out;\n            mix-blend-mode: screen;\n        `;\n        \n        const style = document.createElement('style');\n        style.textContent = `\n            @keyframes dimensionalFlicker {\n                0%, 100% { opacity: 0; transform: scale(1); }\n                50% { opacity: 1; transform: scale(1.02); }\n            }\n        `;\n        \n        if (!document.getElementById('dimensional-flicker-style')) {\n            style.id = 'dimensional-flicker-style';\n            document.head.appendChild(style);\n        }\n        \n        document.body.appendChild(fracture);\n        \n        setTimeout(() => fracture.remove(), 100);\n    }\n    \n    applyTemporalDisplacement(intensity) {\n        document.querySelectorAll('.time-machine-container > *').forEach((element, index) => {\n            const displacement = intensity * 20 * Math.sin(Date.now() * 0.01 + index);\n            element.style.transform = `\n                translateX(${displacement}px)\n                skewX(${intensity * 2}deg)\n            `;\n        });\n    }\n    \n    applyFocus(step, progress) {\n        const target = document.querySelector(step.target);\n        if (!target) return;\n        \n        const rect = target.getBoundingClientRect();\n        const centerX = rect.left + rect.width / 2;\n        const centerY = rect.top + rect.height / 2;\n        \n        // Create focus spotlight effect\n        const spotlight = document.createElement('div');\n        spotlight.style.cssText = `\n            position: fixed;\n            left: ${centerX - 150 * step.intensity}px;\n            top: ${centerY - 150 * step.intensity}px;\n            width: ${300 * step.intensity}px;\n            height: ${300 * step.intensity}px;\n            border-radius: 50%;\n            background: radial-gradient(circle, transparent 40%, rgba(0,0,0,${progress * 0.7}) 80%);\n            pointer-events: none;\n            z-index: 12000;\n            animation: focusPulse ${1000}ms ease-in-out infinite alternate;\n        `;\n        \n        if (!document.querySelector('.focus-spotlight')) {\n            spotlight.className = 'focus-spotlight';\n            document.body.appendChild(spotlight);\n            \n            const style = document.createElement('style');\n            style.textContent = `\n                @keyframes focusPulse {\n                    0% { transform: scale(0.95); opacity: 0.8; }\n                    100% { transform: scale(1.05); opacity: 1; }\n                }\n            `;\n            document.head.appendChild(style);\n            \n            setTimeout(() => spotlight.remove(), step.duration);\n        }\n        \n        // Enhance target element\n        target.style.filter = `brightness(${1 + progress * 0.5}) drop-shadow(0 0 20px rgba(255,255,255,${progress}))`;\n    }\n    \n    applyRotation(step, progress) {\n        const angle = step.angle * progress;\n        \n        if (step.axis === 'z') {\n            document.body.style.transform = `rotateZ(${angle}deg)`;\n        } else if (step.axis === 'x') {\n            document.body.style.transform = `rotateX(${angle}deg)`;\n        } else if (step.axis === 'y') {\n            document.body.style.transform = `rotateY(${angle}deg)`;\n        }\n        \n        // Add rotation momentum effect\n        if (progress > 0.8) {\n            this.addShake(0.3, 15);\n        }\n    }\n    \n    applyEmergence(step, progress) {\n        const scale = step.from.scale + (step.to.scale - step.from.scale) * progress;\n        const blur = step.from.blur + (step.to.blur - step.from.blur) * progress;\n        \n        document.body.style.transform = `scale(${scale})`;\n        document.body.style.filter = `blur(${blur}px) brightness(${1 + (1 - progress) * 0.5})`;\n        \n        // Emergence particles\n        if (Math.random() < 0.3) {\n            this.createEmergenceParticle();\n        }\n    }\n    \n    createEmergenceParticle() {\n        const particle = document.createElement('div');\n        particle.style.cssText = `\n            position: fixed;\n            left: ${Math.random() * window.innerWidth}px;\n            top: ${Math.random() * window.innerHeight}px;\n            width: ${Math.random() * 6 + 2}px;\n            height: ${Math.random() * 6 + 2}px;\n            border-radius: 50%;\n            background: radial-gradient(circle, #ffffff 0%, #00ffff 70%, transparent 100%);\n            pointer-events: none;\n            z-index: 14000;\n            animation: emergenceParticle 2s ease-out forwards;\n        `;\n        \n        const style = document.createElement('style');\n        style.textContent = `\n            @keyframes emergenceParticle {\n                0% {\n                    opacity: 1;\n                    transform: scale(0) translateY(0);\n                }\n                50% {\n                    opacity: 0.8;\n                    transform: scale(1.5) translateY(-50px);\n                }\n                100% {\n                    opacity: 0;\n                    transform: scale(0.5) translateY(-100px);\n                }\n            }\n        `;\n        \n        if (!document.getElementById('emergence-particle-style')) {\n            style.id = 'emergence-particle-style';\n            document.head.appendChild(style);\n        }\n        \n        document.body.appendChild(particle);\n        \n        setTimeout(() => particle.remove(), 2000);\n    }\n    \n    applyStabilization(step, progress) {\n        // Gradual return to normal\n        const stabilizationFactor = 1 - Math.sin(progress * Math.PI * 4) * 0.1;\n        \n        document.body.style.transform = `scale(${stabilizationFactor})`;\n        \n        // Remove any residual effects\n        if (progress > 0.9) {\n            this.resetEffects();\n        }\n    }\n    \n    addShake(intensity, frequency) {\n        this.shake.intensity = intensity;\n        this.shake.frequency = frequency;\n        \n        // Auto-reduce shake over time\n        const reduceShake = () => {\n            this.shake.intensity *= 0.95;\n            if (this.shake.intensity > 0.01) {\n                requestAnimationFrame(reduceShake);\n            } else {\n                this.shake.intensity = 0;\n            }\n        };\n        \n        requestAnimationFrame(reduceShake);\n    }\n    \n    applyEasing(progress, easing) {\n        switch (easing) {\n            case 'easeInQuad':\n                return progress * progress;\n            case 'easeOutQuad':\n                return 1 - (1 - progress) * (1 - progress);\n            case 'easeInOutQuad':\n                return progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;\n            case 'easeInCubic':\n                return progress * progress * progress;\n            case 'easeOutCubic':\n                return 1 - Math.pow(1 - progress, 3);\n            case 'easeInOutCubic':\n                return progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;\n            case 'easeInQuart':\n                return progress * progress * progress * progress;\n            case 'easeOutQuart':\n                return 1 - Math.pow(1 - progress, 4);\n            case 'easeInOutQuart':\n                return progress < 0.5 ? 8 * progress * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 4) / 2;\n            case 'easeInOutSine':\n                return -(Math.cos(Math.PI * progress) - 1) / 2;\n            case 'easeOutBack':\n                const c1 = 1.70158;\n                const c3 = c1 + 1;\n                return 1 + c3 * Math.pow(progress - 1, 3) + c1 * Math.pow(progress - 1, 2);\n            case 'easeOutBounce':\n                const n1 = 7.5625;\n                const d1 = 2.75;\n                if (progress < 1 / d1) {\n                    return n1 * progress * progress;\n                } else if (progress < 2 / d1) {\n                    return n1 * (progress -= 1.5 / d1) * progress + 0.75;\n                } else if (progress < 2.5 / d1) {\n                    return n1 * (progress -= 2.25 / d1) * progress + 0.9375;\n                } else {\n                    return n1 * (progress -= 2.625 / d1) * progress + 0.984375;\n                }\n            default:\n                return progress;\n        }\n    }\n    \n    resetCamera() {\n        this.currentSequence = null;\n        this.resetEffects();\n    }\n    \n    resetEffects() {\n        document.body.style.transform = '';\n        document.body.style.filter = '';\n        document.body.style.perspective = '';\n        \n        const container = document.querySelector('.time-machine-container');\n        if (container) {\n            container.style.transform = '';\n            container.style.transformOrigin = '';\n        }\n        \n        // Reset individual elements\n        document.querySelectorAll('.flux-capacitor, .status-item').forEach(el => {\n            el.style.transform = '';\n            el.style.filter = '';\n        });\n        \n        document.querySelectorAll('.time-machine-container > *').forEach(el => {\n            el.style.transform = '';\n        });\n        \n        // Remove temporary effects\n        document.querySelectorAll('.focus-spotlight, .dimensional-fracture').forEach(el => {\n            el.remove();\n        });\n    }\n    \n    animate() {\n        if (this.shake.intensity > 0) {\n            const shakeX = (Math.random() - 0.5) * this.shake.intensity * 10;\n            const shakeY = (Math.random() - 0.5) * this.shake.intensity * 10;\n            \n            document.body.style.transform += ` translateX(${shakeX}px) translateY(${shakeY}px)`;\n        }\n        \n        requestAnimationFrame(() => this.animate());\n    }\n}\n\n// Initialize when DOM loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    new CinematicCamera();\n});