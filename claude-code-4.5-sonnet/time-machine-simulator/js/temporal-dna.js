class TemporalDNASystem {
    constructor() {
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.dnaStreams = [];
        this.timeHelices = [];
        this.geneticParticles = [];
        this.temporalSequences = [];
        this.time = 0;
        this.evolutionRate = 1.0;
        this.mutationEvents = [];
        
        this.init();
        this.createDNASystems();
        this.animate();
    }
    
    init() {
        this.canvas.style.position = 'fixed';
        this.canvas.style.top = '0';
        this.canvas.style.left = '0';
        this.canvas.style.width = '100%';
        this.canvas.style.height = '100%';
        this.canvas.style.pointerEvents = 'none';
        this.canvas.style.zIndex = '470';
        this.canvas.style.mixBlendMode = 'screen';
        this.canvas.style.opacity = '0.4';
        
        this.resize();
        document.body.appendChild(this.canvas);
        
        this.bindEvents();
    }
    
    resize() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n    }\n    \n    bindEvents() {\n        document.addEventListener('travel-start', () => {\n            this.accelerateEvolution();\n            this.createTemporalMutations();\n        });\n        \n        document.addEventListener('calibrate-start', () => {\n            this.stabilizeSequences();\n        });\n        \n        document.addEventListener('mousemove', (e) => {\n            this.createGeneticInteraction(e.clientX, e.clientY);\n        });\n    }\n    \n    createDNASystems() {\n        // Create main temporal DNA streams\n        for (let i = 0; i < 6; i++) {\n            this.dnaStreams.push(new TemporalDNAStream(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height,\n                'temporal'\n            ));\n        }\n        \n        // Create time helices\n        for (let i = 0; i < 4; i++) {\n            this.timeHelices.push(new TimeHelix(\n                (i + 1) * (this.canvas.width / 5),\n                this.canvas.height / 2\n            ));\n        }\n        \n        // Create genetic particles\n        for (let i = 0; i < 50; i++) {\n            this.geneticParticles.push(new GeneticParticle(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height\n            ));\n        }\n        \n        // Create temporal sequences\n        for (let i = 0; i < 3; i++) {\n            this.temporalSequences.push(new TemporalSequence(\n                Math.random() * this.canvas.width,\n                50 + i * 150\n            ));\n        }\n    }\n    \n    accelerateEvolution() {\n        this.evolutionRate = 3.0;\n        \n        // Create additional DNA streams during time travel\n        for (let i = 0; i < 4; i++) {\n            this.dnaStreams.push(new TemporalDNAStream(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height,\n                'accelerated'\n            ));\n        }\n        \n        // Activate all helices\n        this.timeHelices.forEach(helix => helix.activate());\n    }\n    \n    createTemporalMutations() {\n        for (let i = 0; i < 8; i++) {\n            this.mutationEvents.push(new TemporalMutation(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height\n            ));\n        }\n    }\n    \n    stabilizeSequences() {\n        this.evolutionRate = 1.0;\n        this.timeHelices.forEach(helix => helix.stabilize());\n        this.dnaStreams.forEach(stream => stream.stabilize());\n    }\n    \n    createGeneticInteraction(x, y) {\n        if (Math.random() < 0.05) {\n            this.geneticParticles.push(new GeneticParticle(x, y, true)); // enhanced particle\n        }\n    }\n    \n    update() {\n        this.time += 0.016 * this.evolutionRate;\n        \n        // Update all systems\n        this.dnaStreams = this.dnaStreams.filter(stream => {\n            stream.update(this.time);\n            return !stream.finished;\n        });\n        \n        this.timeHelices.forEach(helix => helix.update(this.time));\n        \n        this.geneticParticles = this.geneticParticles.filter(particle => {\n            particle.update(this.time);\n            return !particle.finished;\n        });\n        \n        this.temporalSequences.forEach(sequence => sequence.update(this.time));\n        \n        this.mutationEvents = this.mutationEvents.filter(mutation => {\n            mutation.update(this.time);\n            return !mutation.finished;\n        });\n        \n        // Spontaneous genetic events\n        if (Math.random() < 0.01) {\n            this.createSpontaneousEvolution();\n        }\n        \n        // Evolution rate decay\n        this.evolutionRate = Math.max(1.0, this.evolutionRate * 0.999);\n    }\n    \n    createSpontaneousEvolution() {\n        if (Math.random() < 0.5) {\n            this.dnaStreams.push(new TemporalDNAStream(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height,\n                'spontaneous'\n            ));\n        } else {\n            this.mutationEvents.push(new TemporalMutation(\n                Math.random() * this.canvas.width,\n                Math.random() * this.canvas.height\n            ));\n        }\n    }\n    \n    render() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        // Render temporal sequences (background)\n        this.temporalSequences.forEach(sequence => sequence.render(this.ctx));\n        \n        // Render time helices\n        this.timeHelices.forEach(helix => helix.render(this.ctx));\n        \n        // Render DNA streams\n        this.dnaStreams.forEach(stream => stream.render(this.ctx));\n        \n        // Render genetic particles\n        this.geneticParticles.forEach(particle => particle.render(this.ctx));\n        \n        // Render mutation events\n        this.mutationEvents.forEach(mutation => mutation.render(this.ctx));\n        \n        // Render evolution statistics\n        this.renderEvolutionStats();\n    }\n    \n    renderEvolutionStats() {\n        this.ctx.save();\n        this.ctx.font = '11px monospace';\n        this.ctx.fillStyle = 'rgba(0, 255, 100, 0.7)';\n        \n        const activeStreams = this.dnaStreams.filter(s => s.active).length;\n        const mutations = this.mutationEvents.length;\n        const particles = this.geneticParticles.length;\n        \n        this.ctx.fillText(`Evolution Rate: ${this.evolutionRate.toFixed(1)}x`, this.canvas.width - 220, 30);\n        this.ctx.fillText(`Active DNA Streams: ${activeStreams}`, this.canvas.width - 220, 50);\n        this.ctx.fillText(`Temporal Mutations: ${mutations}`, this.canvas.width - 220, 70);\n        this.ctx.fillText(`Genetic Particles: ${particles}`, this.canvas.width - 220, 90);\n        \n        this.ctx.restore();\n    }\n    \n    animate() {\n        this.update();\n        this.render();\n        requestAnimationFrame(() => this.animate());\n    }\n}\n\nclass TemporalDNAStream {\n    constructor(x, y, type = 'temporal') {\n        this.x = x;\n        this.y = y;\n        this.type = type;\n        this.length = type === 'accelerated' ? 300 : 200;\n        this.segments = [];\n        this.basePairs = [];\n        this.finished = false;\n        this.active = true;\n        this.life = type === 'spontaneous' ? 400 : 800;\n        this.maxLife = this.life;\n        this.helixRadius = 15;\n        this.pitch = 0.1;\n        this.rotation = 0;\n        this.flowDirection = Math.random() * Math.PI * 2;\n        this.velocity = { x: 0, y: 0 };\n        this.nucleotides = ['A', 'T', 'G', 'C'];\n        this.sequence = [];\n        \n        this.generateSequence();\n        this.createHelixStructure();\n        this.setMovement();\n    }\n    \n    generateSequence() {\n        for (let i = 0; i < this.length / 10; i++) {\n            this.sequence.push({\n                base: this.nucleotides[Math.floor(Math.random() * 4)],\n                complement: '',\n                position: i\n            });\n        }\n        \n        // Generate complementary bases\n        this.sequence.forEach(nucleotide => {\n            switch (nucleotide.base) {\n                case 'A': nucleotide.complement = 'T'; break;\n                case 'T': nucleotide.complement = 'A'; break;\n                case 'G': nucleotide.complement = 'C'; break;\n                case 'C': nucleotide.complement = 'G'; break;\n            }\n        });\n    }\n    \n    createHelixStructure() {\n        for (let i = 0; i < this.length; i += 5) {\n            const t = i / this.length;\n            const helixAngle = t * Math.PI * 8; // Two full turns\n            \n            // Strand 1\n            const x1 = Math.cos(helixAngle) * this.helixRadius;\n            const y1 = Math.sin(helixAngle) * this.helixRadius;\n            \n            // Strand 2 (opposite phase)\n            const x2 = Math.cos(helixAngle + Math.PI) * this.helixRadius;\n            const y2 = Math.sin(helixAngle + Math.PI) * this.helixRadius;\n            \n            this.segments.push({\n                x1: x1,\n                y1: y1,\n                x2: x2,\n                y2: y2,\n                z: i,\n                angle: helixAngle,\n                intensity: 1.0\n            });\n            \n            // Base pairs (connecting the two strands)\n            if (i % 10 === 0) {\n                const seqIndex = Math.floor(i / 10);\n                if (seqIndex < this.sequence.length) {\n                    this.basePairs.push({\n                        x1: x1,\n                        y1: y1,\n                        x2: x2,\n                        y2: y2,\n                        z: i,\n                        base1: this.sequence[seqIndex].base,\n                        base2: this.sequence[seqIndex].complement,\n                        bond: this.getBondStrength(this.sequence[seqIndex].base)\n                    });\n                }\n            }\n        }\n    }\n    \n    getBondStrength(base) {\n        // A-T pairs have 2 hydrogen bonds, G-C pairs have 3\n        return (base === 'A' || base === 'T') ? 2 : 3;\n    }\n    \n    setMovement() {\n        const speed = this.type === 'accelerated' ? 2.0 : 0.5;\n        this.velocity.x = Math.cos(this.flowDirection) * speed;\n        this.velocity.y = Math.sin(this.flowDirection) * speed;\n    }\n    \n    activate() {\n        this.active = true;\n    }\n    \n    stabilize() {\n        this.velocity.x *= 0.5;\n        this.velocity.y *= 0.5;\n    }\n    \n    update(time) {\n        this.rotation += 0.02;\n        \n        // Movement\n        this.x += this.velocity.x;\n        this.y += this.velocity.y;\n        \n        // Wrap around screen\n        if (this.x > window.innerWidth + 50) this.x = -50;\n        if (this.x < -50) this.x = window.innerWidth + 50;\n        if (this.y > window.innerHeight + 50) this.y = -50;\n        if (this.y < -50) this.y = window.innerHeight + 50;\n        \n        // Update segments\n        this.segments.forEach(segment => {\n            segment.intensity += (Math.random() - 0.5) * 0.1;\n            segment.intensity = Math.max(0.5, Math.min(1.5, segment.intensity));\n        });\n        \n        // Random mutations\n        if (Math.random() < 0.001 && this.type !== 'stabilized') {\n            this.mutateSequence();\n        }\n        \n        this.life--;\n        if (this.life <= 0) {\n            this.finished = true;\n        }\n    }\n    \n    mutateSequence() {\n        if (this.sequence.length > 0) {\n            const index = Math.floor(Math.random() * this.sequence.length);\n            const oldBase = this.sequence[index].base;\n            const newBase = this.nucleotides[Math.floor(Math.random() * 4)];\n            \n            this.sequence[index].base = newBase;\n            \n            // Update complement\n            switch (newBase) {\n                case 'A': this.sequence[index].complement = 'T'; break;\n                case 'T': this.sequence[index].complement = 'A'; break;\n                case 'G': this.sequence[index].complement = 'C'; break;\n                case 'C': this.sequence[index].complement = 'G'; break;\n            }\n        }\n    }\n    \n    render(ctx) {\n        const alpha = this.life / this.maxLife;\n        \n        ctx.save();\n        ctx.translate(this.x, this.y);\n        ctx.rotate(this.rotation);\n        \n        // Render helix backbone\n        ctx.strokeStyle = `rgba(0, 255, 150, ${alpha * 0.8})`;\n        ctx.lineWidth = 2;\n        ctx.shadowBlur = 5;\n        ctx.shadowColor = '#00ff96';\n        \n        // Strand 1\n        ctx.beginPath();\n        this.segments.forEach((segment, index) => {\n            const perspective = 1 - (segment.z / this.length) * 0.3;\n            const x = segment.x1 * perspective;\n            const y = (segment.z - this.length/2) * 0.8 + segment.y1 * perspective;\n            \n            if (index === 0) {\n                ctx.moveTo(x, y);\n            } else {\n                ctx.lineTo(x, y);\n            }\n        });\n        ctx.stroke();\n        \n        // Strand 2\n        ctx.beginPath();\n        this.segments.forEach((segment, index) => {\n            const perspective = 1 - (segment.z / this.length) * 0.3;\n            const x = segment.x2 * perspective;\n            const y = (segment.z - this.length/2) * 0.8 + segment.y2 * perspective;\n            \n            if (index === 0) {\n                ctx.moveTo(x, y);\n            } else {\n                ctx.lineTo(x, y);\n            }\n        });\n        ctx.stroke();\n        \n        // Render base pairs\n        this.basePairs.forEach(pair => {\n            const perspective = 1 - (pair.z / this.length) * 0.3;\n            const x1 = pair.x1 * perspective;\n            const y1 = (pair.z - this.length/2) * 0.8 + pair.y1 * perspective;\n            const x2 = pair.x2 * perspective;\n            const y2 = (pair.z - this.length/2) * 0.8 + pair.y2 * perspective;\n            \n            // Base pair connection\n            const bondColor = pair.bond === 3 ? '#ff6600' : '#00ccff';\n            ctx.strokeStyle = `rgba(${bondColor.slice(1, 3)}, ${bondColor.slice(3, 5)}, ${bondColor.slice(5, 7)}, ${alpha})`;\n            ctx.lineWidth = pair.bond;\n            \n            ctx.beginPath();\n            ctx.moveTo(x1, y1);\n            ctx.lineTo(x2, y2);\n            ctx.stroke();\n            \n            // Nucleotide bases\n            ctx.font = '8px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;\n            ctx.textAlign = 'center';\n            \n            ctx.fillText(pair.base1, x1, y1 + 3);\n            ctx.fillText(pair.base2, x2, y2 + 3);\n        });\n        \n        // Type indicator\n        if (this.type !== 'temporal') {\n            ctx.font = '10px monospace';\n            ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;\n            ctx.textAlign = 'center';\n            ctx.fillText(this.type.toUpperCase(), 0, -this.length/2 - 20);\n        }\n        \n        ctx.restore();\n    }\n}\n\nclass TimeHelix {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.active = false;\n        this.radius = 30;\n        this.height = 200;\n        this.rotation = 0;\n        this.timeFlow = [];\n        this.temporalMarkers = [];\n        this.energyLevel = 0;\n        \n        this.createTimeFlow();\n        this.createTemporalMarkers();\n    }\n    \n    createTimeFlow() {\n        for (let i = 0; i < 50; i++) {\n            const t = i / 50;\n            const angle = t * Math.PI * 6; // Three full rotations\n            \n            this.timeFlow.push({\n                angle: angle,\n                height: t * this.height - this.height / 2,\n                intensity: Math.random(),\n                speed: 0.02 + Math.random() * 0.03\n            });\n        }\n    }\n    \n    createTemporalMarkers() {\n        const timePoints = ['PAST', 'PRESENT', 'FUTURE'];\n        \n        timePoints.forEach((label, index) => {\n            this.temporalMarkers.push({\n                label: label,\n                angle: (index / 3) * Math.PI * 2,\n                radius: this.radius + 20,\n                pulse: 0\n            });\n        });\n    }\n    \n    activate() {\n        this.active = true;\n        this.energyLevel = 1.0;\n    }\n    \n    stabilize() {\n        this.energyLevel *= 0.8;\n    }\n    \n    update(time) {\n        this.rotation += 0.01;\n        \n        // Update time flow\n        this.timeFlow.forEach(flow => {\n            flow.angle += flow.speed;\n            flow.intensity += (Math.random() - 0.5) * 0.2;\n            flow.intensity = Math.max(0.3, Math.min(1.5, flow.intensity));\n        });\n        \n        // Update temporal markers\n        this.temporalMarkers.forEach(marker => {\n            marker.pulse += 0.1;\n        });\n        \n        // Energy decay\n        if (this.active) {\n            this.energyLevel *= 0.995;\n            if (this.energyLevel < 0.1) {\n                this.active = false;\n            }\n        }\n    }\n    \n    render(ctx) {\n        ctx.save();\n        ctx.translate(this.x, this.y);\n        \n        // Render time flow helix\n        ctx.strokeStyle = `rgba(100, 255, 200, ${this.active ? this.energyLevel : 0.5})`;\n        ctx.lineWidth = 2;\n        ctx.shadowBlur = 8;\n        ctx.shadowColor = '#64ffc8';\n        \n        ctx.beginPath();\n        this.timeFlow.forEach((flow, index) => {\n            const x = Math.cos(flow.angle + this.rotation) * this.radius;\n            const y = flow.height;\n            \n            if (index === 0) {\n                ctx.moveTo(x, y);\n            } else {\n                ctx.lineTo(x, y);\n            }\n        });\n        ctx.stroke();\n        \n        // Render temporal flow particles\n        this.timeFlow.forEach(flow => {\n            const x = Math.cos(flow.angle + this.rotation) * this.radius;\n            const y = flow.height;\n            \n            ctx.fillStyle = `rgba(100, 255, 200, ${flow.intensity * (this.active ? this.energyLevel : 0.5)})`;\n            ctx.shadowBlur = 5;\n            \n            ctx.beginPath();\n            ctx.arc(x, y, 2, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        // Render temporal markers\n        this.temporalMarkers.forEach(marker => {\n            const x = Math.cos(marker.angle + this.rotation) * marker.radius;\n            const y = Math.sin(marker.pulse) * 10;\n            \n            ctx.font = '12px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${this.active ? this.energyLevel : 0.6})`;\n            ctx.textAlign = 'center';\n            ctx.shadowBlur = 3;\n            ctx.shadowColor = '#ffffff';\n            \n            ctx.fillText(marker.label, x, y);\n        });\n        \n        // Central time core\n        if (this.active) {\n            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);\n            gradient.addColorStop(0, `rgba(255, 255, 255, ${this.energyLevel})`);\n            gradient.addColorStop(0.7, `rgba(100, 255, 200, ${this.energyLevel * 0.7})`);\n            gradient.addColorStop(1, 'transparent');\n            \n            ctx.fillStyle = gradient;\n            ctx.beginPath();\n            ctx.arc(0, 0, 15, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        \n        ctx.restore();\n    }\n}\n\nclass GeneticParticle {\n    constructor(x, y, enhanced = false) {\n        this.x = x;\n        this.y = y;\n        this.vx = (Math.random() - 0.5) * 4;\n        this.vy = (Math.random() - 0.5) * 4;\n        this.size = enhanced ? 4 : 2;\n        this.geneticCode = this.generateGeneticCode();\n        this.enhanced = enhanced;\n        this.finished = false;\n        this.life = enhanced ? 300 : 200;\n        this.maxLife = this.life;\n        this.trail = [];\n        this.maxTrailLength = 10;\n    }\n    \n    generateGeneticCode() {\n        const bases = ['A', 'T', 'G', 'C'];\n        const codeLength = this.enhanced ? 6 : 3;\n        let code = '';\n        \n        for (let i = 0; i < codeLength; i++) {\n            code += bases[Math.floor(Math.random() * 4)];\n        }\n        \n        return code;\n    }\n    \n    update(time) {\n        // Add current position to trail\n        this.trail.push({ x: this.x, y: this.y });\n        if (this.trail.length > this.maxTrailLength) {\n            this.trail.shift();\n        }\n        \n        // Movement\n        this.x += this.vx;\n        this.y += this.vy;\n        \n        // Slight gravity toward center\n        const centerX = window.innerWidth / 2;\n        const centerY = window.innerHeight / 2;\n        const dx = centerX - this.x;\n        const dy = centerY - this.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        \n        if (distance > 0) {\n            const force = 0.001;\n            this.vx += (dx / distance) * force;\n            this.vy += (dy / distance) * force;\n        }\n        \n        // Velocity dampening\n        this.vx *= 0.995;\n        this.vy *= 0.995;\n        \n        // Boundary reflection\n        if (this.x < 0 || this.x > window.innerWidth) this.vx *= -0.8;\n        if (this.y < 0 || this.y > window.innerHeight) this.vy *= -0.8;\n        \n        this.life--;\n        if (this.life <= 0) {\n            this.finished = true;\n        }\n    }\n    \n    render(ctx) {\n        const alpha = this.life / this.maxLife;\n        \n        // Render trail\n        this.trail.forEach((point, index) => {\n            const trailAlpha = (index / this.trail.length) * alpha * 0.5;\n            const trailSize = (index / this.trail.length) * this.size * 0.5;\n            \n            ctx.fillStyle = `rgba(0, 255, 100, ${trailAlpha})`;\n            ctx.beginPath();\n            ctx.arc(point.x, point.y, trailSize, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        // Render particle\n        ctx.save();\n        ctx.shadowBlur = this.enhanced ? 10 : 5;\n        ctx.shadowColor = this.enhanced ? '#ffff00' : '#00ff64';\n        \n        const color = this.enhanced ? '255, 255, 0' : '0, 255, 100';\n        ctx.fillStyle = `rgba(${color}, ${alpha})`;\n        \n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Render genetic code\n        if (this.enhanced) {\n            ctx.font = '8px monospace';\n            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;\n            ctx.textAlign = 'center';\n            ctx.fillText(this.geneticCode, this.x, this.y - this.size - 8);\n        }\n        \n        ctx.restore();\n    }\n}\n\nclass TemporalSequence {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.sequence = this.generateTemporalSequence();\n        this.displayIndex = 0;\n        this.scrollSpeed = 0.1;\n        this.width = 300;\n        \n    }\n    \n    generateTemporalSequence() {\n        const bases = ['A', 'T', 'G', 'C'];\n        const timeEvents = ['PAST', 'NOW', 'FUTURE', 'VOID'];\n        const sequence = [];\n        \n        for (let i = 0; i < 50; i++) {\n            sequence.push({\n                base: bases[Math.floor(Math.random() * 4)],\n                timeEvent: i % 10 === 0 ? timeEvents[Math.floor(Math.random() * 4)] : null,\n                intensity: Math.random()\n            });\n        }\n        \n        return sequence;\n    }\n    \n    update(time) {\n        this.displayIndex += this.scrollSpeed;\n        \n        if (this.displayIndex >= this.sequence.length - 20) {\n            this.displayIndex = 0;\n        }\n        \n        // Update intensities\n        this.sequence.forEach(item => {\n            item.intensity += (Math.random() - 0.5) * 0.1;\n            item.intensity = Math.max(0.3, Math.min(1.0, item.intensity));\n        });\n    }\n    \n    render(ctx) {\n        ctx.save();\n        ctx.font = '14px monospace';\n        ctx.textAlign = 'left';\n        \n        // Render sequence background\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\n        ctx.fillRect(this.x - 10, this.y - 20, this.width, 30);\n        \n        // Render scrolling sequence\n        let xOffset = 0;\n        const startIndex = Math.floor(this.displayIndex);\n        \n        for (let i = 0; i < 20 && (startIndex + i) < this.sequence.length; i++) {\n            const item = this.sequence[startIndex + i];\n            const x = this.x + xOffset;\n            \n            if (item.timeEvent) {\n                ctx.fillStyle = `rgba(255, 255, 0, ${item.intensity})`;\n                ctx.fillText(item.timeEvent, x, this.y);\n                xOffset += ctx.measureText(item.timeEvent).width + 5;\n            } else {\n                const baseColor = this.getBaseColor(item.base);\n                ctx.fillStyle = `rgba(${baseColor}, ${item.intensity})`;\n                ctx.fillText(item.base, x, this.y);\n                xOffset += 15;\n            }\n        }\n        \n        ctx.restore();\n    }\n    \n    getBaseColor(base) {\n        switch (base) {\n            case 'A': return '255, 0, 0';   // Red\n            case 'T': return '0, 0, 255';   // Blue\n            case 'G': return '0, 255, 0';   // Green\n            case 'C': return '255, 165, 0'; // Orange\n            default: return '255, 255, 255';\n        }\n    }\n}\n\nclass TemporalMutation {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.radius = 0;\n        this.maxRadius = 60;\n        this.finished = false;\n        this.life = 180;\n        this.maxLife = 180;\n        this.mutationWaves = [];\n        this.geneticSparks = [];\n        \n        this.createMutationEffects();\n    }\n    \n    createMutationEffects() {\n        for (let i = 0; i < 5; i++) {\n            this.mutationWaves.push({\n                radius: 0,\n                maxRadius: this.maxRadius + i * 15,\n                speed: 1 + i * 0.3,\n                alpha: 1 - i * 0.15\n            });\n        }\n        \n        for (let i = 0; i < 12; i++) {\n            const angle = (i / 12) * Math.PI * 2;\n            this.geneticSparks.push({\n                x: 0,\n                y: 0,\n                vx: Math.cos(angle) * 2,\n                vy: Math.sin(angle) * 2,\n                life: 60,\n                maxLife: 60\n            });\n        }\n    }\n    \n    update(time) {\n        // Update mutation waves\n        this.mutationWaves.forEach(wave => {\n            wave.radius += wave.speed;\n        });\n        \n        // Update genetic sparks\n        this.geneticSparks = this.geneticSparks.filter(spark => {\n            spark.x += spark.vx;\n            spark.y += spark.vy;\n            spark.life--;\n            return spark.life > 0;\n        });\n        \n        this.life--;\n        if (this.life <= 0) {\n            this.finished = true;\n        }\n    }\n    \n    render(ctx) {\n        const alpha = this.life / this.maxLife;\n        \n        ctx.save();\n        ctx.translate(this.x, this.y);\n        \n        // Render mutation waves\n        this.mutationWaves.forEach(wave => {\n            if (wave.radius <= wave.maxRadius) {\n                const waveAlpha = (1 - wave.radius / wave.maxRadius) * wave.alpha * alpha;\n                \n                ctx.strokeStyle = `rgba(255, 50, 150, ${waveAlpha})`;\n                ctx.lineWidth = 2;\n                ctx.shadowBlur = 8;\n                ctx.shadowColor = '#ff3296';\n                \n                ctx.beginPath();\n                ctx.arc(0, 0, wave.radius, 0, Math.PI * 2);\n                ctx.stroke();\n            }\n        });\n        \n        // Render genetic sparks\n        this.geneticSparks.forEach(spark => {\n            const sparkAlpha = (spark.life / spark.maxLife) * alpha;\n            \n            ctx.fillStyle = `rgba(255, 255, 100, ${sparkAlpha})`;\n            ctx.shadowBlur = 5;\n            ctx.shadowColor = '#ffff64';\n            \n            ctx.beginPath();\n            ctx.arc(spark.x, spark.y, 2, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        \n        // Central mutation core\n        const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);\n        coreGradient.addColorStop(0, `rgba(255, 0, 100, ${alpha})`);\n        coreGradient.addColorStop(0.7, `rgba(255, 100, 200, ${alpha * 0.7})`);\n        coreGradient.addColorStop(1, 'transparent');\n        \n        ctx.fillStyle = coreGradient;\n        ctx.beginPath();\n        ctx.arc(0, 0, 15, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Mutation label\n        ctx.font = '10px monospace';\n        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;\n        ctx.textAlign = 'center';\n        ctx.fillText('MUTATION', 0, 25);\n        \n        ctx.restore();\n    }\n}\n\n// Initialize when DOM loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    new TemporalDNASystem();\n});